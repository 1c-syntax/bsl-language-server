# Потерянная переменная (LostVariable)

<!-- Блоки выше заполняются автоматически, не трогать -->
## Описание диагностики
<!-- Описание диагностики заполняется вручную. Необходимо понятным языком описать смысл и схему работу -->
Переменной присваивается значение, которое не используется. Далее переменной еще раз присваивается новое значение.
Подобный код приводит к снижению читабельности кода, также может приводить к снижению производительности.
Может возникать при опечатках, "копипасте" или рефакторинге кода, а также из-за проблем в алгоритме.

В текущей реализации возможны "ложно-положительные" срабатывания, т.е. могут выдаваться замечания к правильному коду, т.к. некоторые варианты кода сложно отличить от правильного. Подробнее в примерах, пункт "Примеры исключений".

## Примеры
<!-- В данном разделе приводятся примеры, на которые диагностика срабатывает, а также можно привести пример, как можно исправить ситуацию -->
Неверный код - безусловная повторная переустановка значения
```bsl
МояПеременная = СтрЗаменить(Текст, " ", ""); // замечание
МояПеременная = СтрЗаменить(Текст, ";", "");
```
Правильный код
```bsl
МояПеременная = СтрЗаменить(Текст, " ", "");
МояПеременная = СтрЗаменить(МояПеременная, ";", "");
```

Или другой подозрительный код - повторная переустановка значения при некотором условии и только потом переменная используется
```bsl
МояПеременная = СтрЗаменить(Текст, " ", ""); // замечание
Если Условие Тогда
    МояПеременная = СтрЗаменить(Текст, ";", "");
    Возврат МояПеременная;
КонецЕсли;
```

А вот такой слегка переделанный код уже не будет выявляться правилом
- т.к. переустановка выполняется не всегда, а только при выполнения условия.
```bsl
МояПеременная = СтрЗаменить(Текст, " ", "");
Если Условие Тогда
    МояПеременная = СтрЗаменить(Текст, ";", "");
КонецЕсли;
Возврат МояПеременная;
```

Часто встречающаяся "ошибка последней строки"
```bsl
ТемаПисьма                             = ДанныеЗаполнения.Тема;// потерялось
ТекстШаблонаПисьмаHTML                 = ДанныеЗаполнения.ТекстHTML;
ТекстШаблонаПисьма                     = ДанныеЗаполнения.Текст;
ТемаПисьма                             = ДанныеЗаполнения.Тема; // а здесь переопредели
Наименование                           = ДанныеЗаполнения.Тема;
```

Еще подозрительный код - переменная `Файл` меняется несколько раз, и во втором случае ошибочно.
```bsl
Процедура ПолучитьФайлОбработки()
    Файл = Новый Файл(КаталогФич); // нет замечания
    Если Не Файл.Существует() Тогда
        Возврат;
    КонецЕсли;

    Файл = Новый Файл(КаталогФич); // замечание
    НачальныйКаталог = КаталогФич;

    Файл = Новый Файл(НачальныйКаталог);
КонецПроцедуры
```

Пример подозрительного кода - Инициализация переменных в начале метода

Начальная инициализация может обмануть, т.к. при переустановке переменной значение может получить другой тип.
Или в текущем коде или в будущем, при переделке кода.
```bsl
Функция ПолучитьПутьФайлаВРабочемКаталоге(ДанныеФайла)
	
	ПолноеИмяФайла = ""; // замечание
	ИмяКаталога = РабочийКаталогПользователя();
	
	// Сперва пытаемся найти такую запись в регистре сведений.
	// тут может быть неточность, т.к. 
	ПолноеИмяФайла = ДанныеФайла.ПолноеИмяФайлаВРабочемКаталоге;
```
или похожий, чуть более сложный кейс
```
	РезультатОбновления = НовыйРезультатОбновления();
	
	ДвоичныеДанные = СкачатьФайлОбработкиНаКлиентеНаСервере(
		ЭтотОбъект.ПараметрыРаботы.АдресПубликацииВебВитрины, 
		ЭтотОбъект.ПараметрыОбновления);
	
	Если Не ЗначениеЗаполнено(ДвоичныеДанные) Тогда
		РезультатОбновления.ТекстОшибки = "Не удалось скачать файл обработки.";
		Возврат РезультатОбновления;
	КонецЕсли;
	
    // реальный метод ниже может вернуть что угодно сейчас или в будущем
	РезультатОбновления = ЭтотОбъект.УстановитьОбработкуНаСервере(ДвоичныеДанные,
		ЭтотОбъект.ПараметрыРаботы);
```

**Примеры исключений**

- 1 в коллекцию добавляются разные значения без явного переиспользования
```bsl
ВидПрава = ВидыПрав.Добавить(); // будет выдано замечание, хотя код валиден
ВидПрава = ВидыПрав.Добавить();

НовыйПереход = ТаблицаПереходовНоваяСтрока("Начало"); // будет выдано замечание, хотя код валиден
НовыйПереход = ТаблицаПереходовНоваяСтрока("НастройкаВыгрузки");
```
Код выше вполне валиден, но его можно улучшить и упростить, явно выразив свои намерения, избавившись от присваивания переменным и дублирования имен переменных
Исправленный код
```bsl
ВидыПрав.Добавить();
ВидыПрав.Добавить();

ТаблицаПереходовНоваяСтрока("Начало");
ТаблицаПереходовНоваяСтрока("НастройкаВыгрузки");
```

Пример полезного замечания для подобных дублей добавления в коллекцию - пример из типовой конфигурации
```bsl
ВидПрава = ВидыПрав.Добавить(); // вот тут ошибка!
ВидПрава = "Просмотр"; // т.к. ниже опечатка, автор кода забыл добавить .Имя
ВидПрава.Интерактивное = Истина;

ВидПрава = ВидыПрав.Добавить();
ВидПрава.Имя = "Редактирование";
```

- 2 обработка переменных в блоках Попытка и Исключение
```bsl
Процедура УстановитьБлокировку()
    Блокировка = Новый БлокировкаДанных;

    НачатьТранзакцию();
    Попытка
        ЭтоОшибкаБлокировки = Истина; // будет выдано замечание, хотя код валиден
        Блокировка.Заблокировать(); // здесь возможно исключение, и поэтому до следующей строки выполнение может не дойти

        ЭтоОшибкаБлокировки = Ложь;
        ЗафиксироватьТранзакцию();
    Исключение
        ОтменитьТранзакцию();
        Если ЭтоОшибкаБлокировки Тогда
          ОбработкаОшибкиБлокировки();
        КонецЕсли;
    КонецПопытки;
КонецПроцедуры
```

## Источники
<!-- Необходимо указывать ссылки на все источники, из которых почерпнута информация для создания диагностики -->
* [MITRE, CWE-563 - Assignment to Variable without Use](https://cwe.mitre.org/data/definitions/563.html)
* [MITRE, CWE-1109 - Use of Same Variable for Multiple Purposes](https://cwe.mitre.org/data/definitions/1109.html)
* [PVS-Studio.V763. Parameter is always rewritten in function body before being used.](https://pvs-studio.com/ru/docs/warnings/v763)
