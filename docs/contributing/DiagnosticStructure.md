# Структура диагностики, назначение и содержимое файлов

В данной статье содержится информация о правилах использования, создания и шаблонах содержимого диагностики.

- [Структура диагностики, назначение и содержимое файлов](#%d0%a1%d1%82%d1%80%d1%83%d0%ba%d1%82%d1%83%d1%80%d0%b0-%d0%b4%d0%b8%d0%b0%d0%b3%d0%bd%d0%be%d1%81%d1%82%d0%b8%d0%ba%d0%b8-%d0%bd%d0%b0%d0%b7%d0%bd%d0%b0%d1%87%d0%b5%d0%bd%d0%b8%d0%b5-%d0%b8-%d1%81%d0%be%d0%b4%d0%b5%d1%80%d0%b6%d0%b8%d0%bc%d0%be%d0%b5-%d1%84%d0%b0%d0%b9%d0%bb%d0%be%d0%b2)
	- [Состав диагностики](#%d0%a1%d0%be%d1%81%d1%82%d0%b0%d0%b2-%d0%b4%d0%b8%d0%b0%d0%b3%d0%bd%d0%be%d1%81%d1%82%d0%b8%d0%ba%d0%b8)
	- [Класс реализации диагностики](#%d0%9a%d0%bb%d0%b0%d1%81%d1%81-%d1%80%d0%b5%d0%b0%d0%bb%d0%b8%d0%b7%d0%b0%d1%86%d0%b8%d0%b8-%d0%b4%d0%b8%d0%b0%d0%b3%d0%bd%d0%be%d1%81%d1%82%d0%b8%d0%ba%d0%b8)
		- [Класс диагностики, реализующий интерфейс BSLDiagnostic](#%d0%9a%d0%bb%d0%b0%d1%81%d1%81-%d0%b4%d0%b8%d0%b0%d0%b3%d0%bd%d0%be%d1%81%d1%82%d0%b8%d0%ba%d0%b8-%d1%80%d0%b5%d0%b0%d0%bb%d0%b8%d0%b7%d1%83%d1%8e%d1%89%d0%b8%d0%b9-%d0%b8%d0%bd%d1%82%d0%b5%d1%80%d1%84%d0%b5%d0%b9%d1%81-bsldiagnostic)
		- [Класс диагностики, унаследованный от AbstractVisitorDiagnostic](#%d0%9a%d0%bb%d0%b0%d1%81%d1%81-%d0%b4%d0%b8%d0%b0%d0%b3%d0%bd%d0%be%d1%81%d1%82%d0%b8%d0%ba%d0%b8-%d1%83%d0%bd%d0%b0%d1%81%d0%bb%d0%b5%d0%b4%d0%be%d0%b2%d0%b0%d0%bd%d0%bd%d1%8b%d0%b9-%d0%be%d1%82-abstractvisitordiagnostic)
		- [Класс диагностики, унаследованный от AbstractListenerDiagnostic **(В РАЗРАБОТКЕ)**](#%d0%9a%d0%bb%d0%b0%d1%81%d1%81-%d0%b4%d0%b8%d0%b0%d0%b3%d0%bd%d0%be%d1%81%d1%82%d0%b8%d0%ba%d0%b8-%d1%83%d0%bd%d0%b0%d1%81%d0%bb%d0%b5%d0%b4%d0%be%d0%b2%d0%b0%d0%bd%d0%bd%d1%8b%d0%b9-%d0%be%d1%82-abstractlistenerdiagnostic-%d0%92-%d0%a0%d0%90%d0%97%d0%a0%d0%90%d0%91%d0%9e%d0%a2%d0%9a%d0%95)
	- [Класс теста диагностики](#%d0%9a%d0%bb%d0%b0%d1%81%d1%81-%d1%82%d0%b5%d1%81%d1%82%d0%b0-%d0%b4%d0%b8%d0%b0%d0%b3%d0%bd%d0%be%d1%81%d1%82%d0%b8%d0%ba%d0%b8)
		- [Тест диагностики](#%d0%a2%d0%b5%d1%81%d1%82-%d0%b4%d0%b8%d0%b0%d0%b3%d0%bd%d0%be%d1%81%d1%82%d0%b8%d0%ba%d0%b8)
		- [Тест метода конфигурирования для параметризованных диагностик](#%d0%a2%d0%b5%d1%81%d1%82-%d0%bc%d0%b5%d1%82%d0%be%d0%b4%d0%b0-%d0%ba%d0%be%d0%bd%d1%84%d0%b8%d0%b3%d1%83%d1%80%d0%b8%d1%80%d0%be%d0%b2%d0%b0%d0%bd%d0%b8%d1%8f-%d0%b4%d0%bb%d1%8f-%d0%bf%d0%b0%d1%80%d0%b0%d0%bc%d0%b5%d1%82%d1%80%d0%b8%d0%b7%d0%be%d0%b2%d0%b0%d0%bd%d0%bd%d1%8b%d1%85-%d0%b4%d0%b8%d0%b0%d0%b3%d0%bd%d0%be%d1%81%d1%82%d0%b8%d0%ba)
		- [Тест "быстрых замен" **(В РАЗРАБОТКЕ)**](#%d0%a2%d0%b5%d1%81%d1%82-%22%d0%b1%d1%8b%d1%81%d1%82%d1%80%d1%8b%d1%85-%d0%b7%d0%b0%d0%bc%d0%b5%d0%bd%22-%d0%92-%d0%a0%d0%90%d0%97%d0%a0%d0%90%d0%91%d0%9e%d0%a2%d0%9a%d0%95)
	- [Ресурсы диагностики](#%d0%a0%d0%b5%d1%81%d1%83%d1%80%d1%81%d1%8b-%d0%b4%d0%b8%d0%b0%d0%b3%d0%bd%d0%be%d1%81%d1%82%d0%b8%d0%ba%d0%b8)
	- [Ресурсы теста диагностики](#%d0%a0%d0%b5%d1%81%d1%83%d1%80%d1%81%d1%8b-%d1%82%d0%b5%d1%81%d1%82%d0%b0-%d0%b4%d0%b8%d0%b0%d0%b3%d0%bd%d0%be%d1%81%d1%82%d0%b8%d0%ba%d0%b8)
	- [Описание диагностики](#%d0%9e%d0%bf%d0%b8%d1%81%d0%b0%d0%bd%d0%b8%d0%b5-%d0%b4%d0%b8%d0%b0%d0%b3%d0%bd%d0%be%d1%81%d1%82%d0%b8%d0%ba%d0%b8)

## Состав диагностики

Диагностика состоит из набора файлов, подробное описание которых приведено в разделах ниже.  
Необходимый набор файлов в составе диагностики на момент написания статьи и правила их именования

- Класс реализации диагностики.                 Имя файла образуется по принципу `%КлючДиагностики%` + `Diagnosctic.java`
- Класс теста диагностики.                      Имя файла образуется по принципу `%КлючДиагностики%` + `DiagnoscticTest.java`
- Файл ресурса диагностики на русском языке.    Имя файла образуется по принципу `%КлючДиагностики%` + `Diagnosctic_ru.properties`
- Файл ресурса диагностики на английском языке. Имя файла образуется по принципу `%КлючДиагностики%` + `Diagnosctic_en.properties`
- Файл ресурса (фикстура) теста.                Имя файла образуется по принципу `%КлючДиагностики%` + `Diagnosctic.bsl`
- Файл описания диагностики на русском языке.   Имя файла образуется по принципу `%КлючДиагностики%` + `.md`
- Файл ресурса диагностики на английском языке. Имя файла образуется по принципу `%КлючДиагностики%` + `.md`

**Примечание:**  
Для создания нужных файлов в нужных местах, необходимо выполнить команду `gradlew newDiagnostic --key="KeyDiagnostic"`, вместо `KeyDiagnostic` необходимо указть ключ своей диагностики. Подробная информация в справке `gradlew -q help --task newDiagnostic`.

## Класс реализации диагностики

Диагностика реализуется посредством добавления java-класса в пакет `com.github._1c_syntax.bsl.languageserver.diagnostics` в каталоге `src/main/java`.  

В теле файла, нужно указать пакет, в который добавлен класс и блок импорта _(при использовании ide список импорта обновляется автоматически)_. Необходимо следить за тем, чтобы импортировались **только** то, что необходимо для реализации, все неиспользуемое должно быть **удалено** _(если [настройки](EnvironmentSetting.md) выполнены верно, то ide сделает все автоматически)_.

Каждый класс диагностики должен иметь аннотацию `@DiagnosticMetadata`, содержащую метаданные диагностики. Актуальное содержимое всегда можно получить изучив [файл](src/main/java/org/github/_1c_syntax/bsl/languageserver/diagnostics/metadata/DiagnosticMetadata.java).

На момент написания статьи имеются следующие свойства:

- Тип диагностики `type` и ее важность `severity`, для каждой диагностики обязательно их определение. Для того, чтобы правильно выбрать тип и важность диагностики, можно обратиться к [статье](DiagnosticTypeAndSeverity.md).
- Время на исправление замечания `minutesToFix` (по умолчанию 0). Данное значение используется при расчете общего техдолга проекта в трудозатрах на исправление всех замечаний (сумма времени на исправление по всем обнаруженным замечаниям). Стоит указывать время, максимально реалистичное, которое разработчик должен потратить на исправление.
- Границы применимости `scope` (по умолчанию `ALL`, т.е. без ограничения). BSL LS поддерживает несколько языков (oscript и bsl) и диагностики могут применяться как к одному конкретному языку, так и ко всем сразу. 
- Активность правила по-умолчанию `activatedByDefault` (по умолчанию `Истина`). При разработке экспериментальных, спорных либо не применимых в большинстве проектов, стоит по умолчанию отключать диагностику, активацию выполнит конечный пользователь решения.

Последние два могут быть опущены.

Пример аннотации

```java
@DiagnosticMetadata(
  type = DiagnosticType.CODE_SMELL,    // Тип Дефект кода
  severity = DiagnosticSeverity.MINOR, // Важность Незначительный
  minutesToFix = 1,                    // Время на исправление 1 минута
  activatedByDefault = false,          // По умолчанию деактивирована
  scope = DiagnosticScope.BSL          // Применяется только для BSL
)
```

Класс должен реализовывать интерфейс `BSLDiagnostic`. Если диагностика основывается на AST дереве, то класс реализации должен быть унаследован от одного из классов ниже, реализующих `BSLDiagnostic`:

- при необходимости анализа посещения узла / последовательности узлов, использовать стратегию `слушателя` нужно наслодовать класс от `AbstractListenerDiagnostic`
- в остальных случаях нужно использовать стратегию `визитера` и `AbstractVisitorDiagnostic`

Примеры

```java
public class TemplateDiagnostic implements BSLDiagnostic
```

```java
public class TemplateDiagnostic extends AbstractVisitorDiagnostic
```

```java
public class TemplateDiagnostic extends AbstractListenerDiagnostic

```

Диагностика может предоставлять т.н. `быстрые исправления`, для чего класс диагностики должен реализовывать интерфейс `QuickFixProvider`. Подробно о добавлении `быстрых исправлений` в диагностику написано [статье](DiagnosticQuickFix.md).

Примеры

```java
public class TemplateDiagnostic implements BSLDiagnostic, QuickFixProvider
```

```java
public class TemplateDiagnostic extends AbstractVisitorDiagnostic implements QuickFixProvider
```

```java
public class TemplateDiagnostic extends AbstractListenerDiagnostic implements QuickFixProvider
```

После объявления класса, для параметрирезуемых диагностик располагается блок с их параметрами. Подробно о параметрах диагностик написано в [статье](DiagnostcAddSettings.md).

Ниже приведены отличия в реализации классов диагностик.

### Класс диагностики, реализующий интерфейс BSLDiagnostic

В классе необходимо определить защищенное поле `diagnosticStorage` типа `DiagnosticStorage`, которое будет хранилищем обнаруженных замечний.

```java
protected DiagnosticStorage diagnosticStorage = new DiagnosticStorage(this);
```

В классе обязательно должен быть реализован метод `getDiagnostics` принимающий контекст анализируемого файла и возвращающий список обнаруженных замечаний `List<Diagnostic>`.  
Ниже приведена общая структура метода

```java
  @Override
  public List<Diagnostic> getDiagnostics(DocumentContext documentContext) {
    // Очистка хранилища диагностик
    diagnosticStorage.clearDiagnostics();

    documentContext.getComments()  // Получение коллекции токенов, в примере комментариев
      .parallelStream()
      .filter((Token t) ->         // Поиск "нужных", т.е. тех, на обнаружение которых направлена диагностика
        !goodCommentPattern.matcher(t.getText()).matches())
      .sequential()
      .forEach((Token t) ->        // Добавление замечаний, в примере на каждый токен отдельное замечание
        diagnosticStorage.addDiagnostic(t));

    // Возврат обнаруженных замечаний
    return diagnosticStorage.getDiagnostics();
  }
```

### Класс диагностики, унаследованный от AbstractVisitorDiagnostic

В классе диагностики необходимо реализовать методы всех соответствующих `визитеров AST`, в соответствии грамматикой языка, описанной в проекте [BSLParser](https://github.com/1c-syntax/bsl-parser/blob/master/src/main/antlr/BSLParser.g4).  Полный список существующих методов-визитеров находится в классе `BSLParserBaseVisitor`. Необходимо обратить внимание, что для упрощения добавлены `обобщенные` визитеры, например вместо реализации `visitFunction` для функции и `visitProcedure` для процедуры можно использовать `visitSub`, обобщающий работу с методами.

В качестве параметра, в каждый метод визитера передается узел AST соответствующего типа. В теле метода необходимо проанализировать узел и/или его дочерние узлы и принять решение о наличии замечания. При обнаружении проблемы, необходимо добавить замечание в хранилище `diagnosticStorage` _(поле уже определено в абстрактном классе)_. Замечания может быть привязано как непосредственно к переданному узлу, так и к его дочерним или родительским узлам, к нужному блоку кода.

Примерная структура метода

```java
  @Override
  public ParseTree visitModuleVar(BSLParser.ModuleVarContext ctx) {                 // Визитер для переменных модуля
    if(Trees.findAllRuleNodes(ctx, BSLParser.RULE_compilerDirective).size() > 1) {  // Поиск нужных дочерних узлов
      diagnosticStorage.addDiagnostic(ctx);                                         // Добавление замечания на весь узел
    }
    return ctx;
  }
```

Если диагностика **не предусматривает** анализ вложенных блоков, то она должна возвращать переданный входной параметр, в противном случае необходимо вызвать аналогичный `super-метод`.  
Следует внимательно относится к этому правилу, т.к. оно позволит сэкономить ресурсы приложения не выполняя бессмысленный вызов.

Примеры:

- Диагностика для метода или файла должна сразу возвращать значение, т.к. вложенных методов / файлов не существует
- Диагностика для блока условия или области должна вызывать `super-метод`, т.к. они существуют и используются (например `return super.visitSub(ctx)` для методов)

### Класс диагностики, унаследованный от AbstractListenerDiagnostic **(В РАЗРАБОТКЕ)**

_**<В разработке>**_

## Класс теста диагностики

При написании тестов используется фреймворк [JUnit5](https://junit.org/junit5/), для утверждений используется библиотека [AssertJ](https://joel-costigliola.github.io/assertj/), предоставляющая [текучий/fluent-интерфейс](https://ru.wikipedia.org/wiki/Fluent_interface) "ожиданий", подобно привычной многим библиотеке [asserts](https://github.com/oscript-library/asserts) для [OneScript](http://oscript.io/).

Теста реализуется посредством добавления java-класса в пакет `com.github._1c_syntax.bsl.languageserver.diagnostics` в каталоге `src/test/java`.  

В теле файла, нужно указать пакет, в который добавлен класс и блок импорта _(аналогично классу реализации диагностики)_.  
В файле необходимо создать одноименный файлу класс, унаследованый от класса `AbstractDiagnosticTest` для созданного класса диагностики.

Пример тестового класса

```java
package com.github._1c_syntax.bsl.languageserver.diagnostics;

import org.eclipse.lsp4j.Diagnostic;
import com.github._1c_syntax.bsl.languageserver.utils.RangeHelper;
import org.junit.jupiter.api.Test;

import java.util.List;

import static org.assertj.core.api.Assertions.assertThat;

class TemplateDiagnosticTest extends AbstractDiagnosticTest<TemplateDiagnostic> {

    TemplateDiagnosticTest() {
        super(TemplateDiagnostic.class);
    } 
}
```

Для добавления нового теста в созданный класс, необходимо добавить процедуру, аннотированную как тест `@Test`.

В тестовом классе обязательно должны присутствовать методы для тестирования

- тест диагностики, саой по себе
- тест метода конфигурирования для параметризованных диагностик
- тест "быстрых замен" при их налиичии

### Тест диагностики

Упрощенно, тест диагностики состоит из следующих шагов

- получение списка замечаний диагностики
- проверка количества срабатываний
- проверка местоположения срабатываний

Первый шагом необходимо получить список замечаний диагностики вызовом метода `getDiagnostics()` _(реализован в классе `AbstractDiagnosticTest`)_. При вызове этого метода будет выполнен анализ файла ресурса диагностики и возвращен список замечаний в нем.  
Следующим шагом необходимо, с помощью утверждения `hasSize()` убедиться, что замечаний зафиксированно столько, сколько допущенно в фикстурах.  
После этого, необходимо удостовериться, что замечания обнаружены верно, для чего нужно сравнить область замечания, полученную методом `getRange()`, с ожидаемой областью _(стоит использовать класс `RangeHelper` для упрощения формирования контрольнх значений)_.  
В случае использования шаблонного текста сообщения об ошибке замечания, необходимо в тесте проверить и его, получив текст сообщения об ошибке методом `getMessage()` диагностики.

Пример тестового метода

```java
    @Test
    void test() {
        List<Diagnostic> diagnostics = getDiagnostics();   // получение списка замечаний диагностики

        assertThat(diagnostics).hasSize(2);                // проверка количества обнаруженных замечаний

    // проверка частных случаев
    assertThat(diagnostics)
      .anyMatch(diagnostic -> diagnostic.getRange().equals(RangeHelper.newRange(27, 4, 27, 29)))
      .anyMatch(diagnostic -> diagnostic.getRange().equals(RangeHelper.newRange(40, 4, 40, 29)));
    }
```

### Тест метода конфигурирования для параметризованных диагностик

Тесты для метода конфигурирования должны покрывать все возможные варианты настроек и их комбинаций. Тест имеет практически ту же структуру, что и тест диагностики, за исключение установки параметров диагностики перед получением спсика замечаний.  
Перед установкой новых значений параметров диагностики, необходимо получить настройки диагностики по умолчанию методом `DiagnosticProvider.getDefaultDiagnosticConfiguration()` для текущего объекта диагностики `getDiagnosticInstance()`. Полученный результат представляет собой соответствие, в котором, методом `put`, необходимо изменить значения нужных параметров. Применение измененных настроек выполняется методом `configure()` текущего объекта диагностики `getDiagnosticInstance()`.

Пример тестового метода

```java
    @Test
    void testConfigure() {
        // получение настроек диагностики по умолчанию
        Map<String, Object> configuration = DiagnosticProvider.getDefaultDiagnosticConfiguration(getDiagnosticInstance());

        configuration.put("templateParem", "newValue");     // установка параметру "templateParem" значения "newValue"
        getDiagnosticInstance().configure(configuration);   // применение настроек

        List<Diagnostic> diagnostics = getDiagnostics();    // получение списка замечаний диагностики

        assertThat(diagnostics).hasSize(2);                 // проверка количества обнаруженных замечаний

    // проверка частных случаев
    assertThat(diagnostics)
      .anyMatch(diagnostic -> diagnostic.getRange().equals(RangeHelper.newRange(27, 4, 27, 29)))
      .anyMatch(diagnostic -> diagnostic.getRange().equals(RangeHelper.newRange(40, 4, 40, 29)));
    }
```

### Тест "быстрых замен" **(В РАЗРАБОТКЕ)**

_**<В разработке>**_

## Ресурсы диагностики

BSL LS поддерживает два языка в диагностиках: русский и английский, поэтому в состав диагностики входит два файла ресурсов, располагаемых в каталоге `src/main/resources` в пакете `com.github._1c_syntax.bsl.languageserver.diagnostics`, по одному для каждого языка. Структура файлов одинакова: это текстовый файл в UTF-8 кодировки, каждая строка которого содержит пару "Ключ=Значение".

Обязательные параметры, используемые при добавлении замечания по диагностике методам `diagnosticStorage.addDiagnostic`

- diagnosticMessage - Сообщение замечания. Значение поддерживает параметризацию (см `String.format`)
- diagnosticName - Название диагностики, человекопонятное

Для `быстрых исправлений` применяется параметр `quickFixMessage`, содержащий описание действия-исправления.

## Ресурсы теста диагностики

В качестве фикстур используется содержимое ресурсного файла теста, расположенного в каталоге `src/test/resources` в пакете `diagnostics`. Файл должен содержать необходимые примеры кода на языке 1С _(или oscript)_.  
Необходимо добавлять как ошиочный, так и корректный код, **помечая с помощью комментариев места, где диагностика должна зафиксировать замечания, а где нет**. Лукчше всего, если тестовые примеры будут `реальиными`, из практики, а не синтетическими, придуманными `под диагностику`.

## Описание диагностики

Описание диагностики создается в формате [Markdown](https://ru.wikipedia.org/wiki/Markdown) в двух вариантах - для русского и английчского языков. Файлы с описанием располагаются в каталоге `docs/diagnostics` для русского языка, для английского в `docs/diagnostics`.  
Файл в общем случае описания имеет следующую структуру

- Заголовок, равный значению `diagnosticName` из файла ресурса диагностики соответствующего языка
- Тело с описание диагностики, указанием "почему так плохо"
- Примеры плохого и хорошего кода
- Ссылки на источники, если диагностика является реализацией стандарта (например на [ИТС](https://its.1c.ru)).
- Алгоритм работы диагностики для сложных
- Исключительные ситуации, когда диагностика не детектирует замечание
- Описание параметров диагностики при их наличии

Кроме непосредственно создания файлов описания диагностики, необходимо обновлять индекс-файлы `index.md` для каждого языка, добавляя диагностику в таблицу реализованных.
