# Структура диагностики, назначение и содержимое файлов

В данной статье содержится информация о правилах использования, создания и шаблонах содержимого диагностики.

## Класс реализации диагностики

Диагностика реализуется посредством добавления java-класса в пакет `org.github._1c_syntax.bsl.languageserver.diagnostics` в каталоге `src/main/java`.  

Файл начинается с блока лицензии, содержимое которой можно скопировать из любой уже реализованной диагностики, [например](src/main/java/org/github/_1c_syntax/bsl/languageserver/diagnostics/CanonicalSpellingKeywordsDiagnostic.java).

После лицензции необходимо указать пакет, в который добавлен класс и блок импорта _(при использовании ide список импорта обновляется автоматически)_. Необходимо следить за тем, чтобы импортировались **только** то, что необходимо для реализации, все неиспользуемое должно быть **удалено**.

Каждый класс диагностики должен иметь аннотацию `@DiagnosticMetadata`, содержащую метаданные диагностики. Актуальное содержимое всегда можно получить изучив [файл](src/main/java/org/github/_1c_syntax/bsl/languageserver/diagnostics/metadata/DiagnosticMetadata.java).

На момент написания статьи имеются следующие свойства:

- Тип диагностики `type` и ее важность `severity`, для каждой диагностики обязательно их определение. Для того, чтобы правильно выбрать тип и важность диагностики, можно обратиться к [статье](docs/contributing/DiagnosticTypeAndSeverity.md).
- Границы применимости `scope` (по умолчанию `ALL`, т.е. без ограничения). BSL LS поддерживает несколько языков (oscript и bsl) и диагностики могут применяться как к одному конкретному языку, так и ко всем сразу. 
- Время на исправление `minutesToFix` (по умолчанию 0) замечания. Данное значение используется при расчете общего техдолга проекта в трудозатрах на исправление всех замечаний (сумма времени на исправление по всем обнаруженным замечаниям). Стоит указывать время, максимально реалистичное, которое разработчик должен потратить на исправление.
- Активность правила по-умолчанию `activatedByDefault` (по умолчанию `Истина`). При разработке экспериментальных, спорных диагностик либо диагностиках не применимых в большинстве проектах можно стоит по умолчанию отключать, активацию выполнит конечный пользователь решения.

Пример аннотации

```java
@DiagnosticMetadata(
  type = DiagnosticType.CODE_SMELL,    // Тип Дефект кода
  severity = DiagnosticSeverity.MINOR, // Важность Незначительный
  minutesToFix = 1,                    // Время на исправление 1 минута
  activatedByDefault = false,          // По умолчанию деактивирована
  scope = DiagnosticScope.BSL          // Применяется только для BSL
)
```

Имя класса обязательно должно иметь суффикс `Diagnostic`, а сам класс должен реализовывать интерфейс `BSLDiagnostic`. В том случае, когда необходимо диагностика основывается на AST дереве, то класс должен быть унаследован от абстрактного класса `AbstractVisitorDiagnostic`, который в свою очередь реализует интерфейс `BSLDiagnostic`, а также предоставляет набор расширений для простой работы с AST (в частности `визитеры`).  

Пример класса без использования AST

```java
public class TemplateDiagnostic implements BSLDiagnostic
```

Пример класса с использованием AST

```java
public class TemplateDiagnostic extends AbstractVisitorDiagnostic
```

Диагностика может предоставлять т.н. `быстрые исправления`, для чего класс диагностики должен реализовывать интерфейс `QuickFixProvider`. Подробно о добавлении `быстрых исправлений` в диагностику написано [статье](docs/contributing/DiagnosticQuickFix.md).

Пример класса без использования AST с быстрыми исправлениями

```java
public class TemplateDiagnostic implements BSLDiagnostic, QuickFixProvider
```

Пример класса с использованием AST и быстрыми исправлениями

```java
public class TemplateDiagnostic extends AbstractVisitorDiagnostic implements QuickFixProvider
```

После объявления класса, для параметрирезуемых диагностик располагается блок с их параметрами. Подробно о параметрах диагностик написано в [статье](docs/contributing/DiagnostcAddSettings.md).

Ниже приведены отличия в реализации классов диагностик.

### Класс диагностики, реализующий интерфейс BSLDiagnostic

В классе необходимо определить защищенное поле `diagnosticStorage` типа `DiagnosticStorage`, которое будет хранилищем обнаруженных замечний.

```java
protected DiagnosticStorage diagnosticStorage = new DiagnosticStorage(this);
```

В классе обязательно должен быть реализован метод `getDiagnostics` принимающий контекст анализируемого файла и возвращающий список обнаруженных замечаний `List<Diagnostic>`.  
Ниже приведена общая структура метода

```java
  @Override
  public List<Diagnostic> getDiagnostics(DocumentContext documentContext) {
    // Очистка хранилища диагностик
    diagnosticStorage.clearDiagnostics();

    documentContext.getComments()  // Получение коллекции токенов, в примере комментариев
      .parallelStream()
      .filter((Token t) ->         // Поиск "нужных", т.е. тех, на обнаружение которых направлена диагностика
        !goodCommentPattern.matcher(t.getText()).matches())
      .sequential()
      .forEach((Token t) ->        // Добавление замечаний, в примере на каждый токен отдельное замечание
        diagnosticStorage.addDiagnostic(t));

    // Возврат обнаруженных замечаний
    return diagnosticStorage.getDiagnostics();
  }
```

### Класс диагностики, унаследованный от AbstractVisitorDiagnostic

В классе диагностики необходимо реализовать методы всех соответствующих `визитеров AST`, в соответствии грамматикой языка, описанной в проекте [BSLParser](https://github.com/1c-syntax/bsl-parser/blob/master/src/main/antlr/BSLParser.g4).  Полный список существующих методов-визитеров находится в классе `BSLParserBaseVisitor`. Необходимо обратить внимание, что для упрощения добавлены `обобщенные` визитеры, например вместо реализации `visitFunction` для функции и `visitProcedure` для процедуры можно использовать `visitSub`, обобщающий работу с методами.

В качестве параметра, в каждый метод визитера передается узел AST соответствующего типа. В теле метода необходимо проанализировать узел и/или его дочерние узлы и принять решение о наличии замечания. При обнаружении проблемы, необходимо добавить замечание в хранилище `diagnosticStorage`. Замечания может быть привязано как непосредственно к переданному узлу, так и к его дочерним или родительским узлам, к нужному блоку кода.

Примерная структура метода

```java
  @Override
  public ParseTree visitModuleVar(BSLParser.ModuleVarContext ctx) {                 // Визитер для переменных модуля
    if(Trees.findAllRuleNodes(ctx, BSLParser.RULE_compilerDirective).size() > 1) {  // Поиск нужных дочерних узлов
      diagnosticStorage.addDiagnostic(ctx);                                         // Добавление замечания на весь узел
    }
    return ctx;
  }
```

Если диагностика **не предусматривает** анализ вложенных блоков, то она должна возвращать переданный входной параметр, в противном случае необходимо вызвать аналогичный `super-метод`.  
Следует внимательно относится к этому правилу, т.к. оно позволит сэкономить ресурсы приложения не выполняя бессмысленный вызов.

Примеры:

- Диагностика для метода или файла должна сразу возвращать значение, т.к. вложенных методов / файлов не существует
- Диагностика для блока условия или области должна вызывать `super-метод`, т.к. они существуют и используются (например `return super.visitSub(ctx)` для методов)

## Класс теста диагностики

## Ресурсы диагностики

## Ресурсы теста диагностики

## Описание диагностики

<Заготовка>

<При описании типа и важности диагностики неоходимо сослаться на docs/contributing/DiagnosticTypeAndSeverity.md> 
