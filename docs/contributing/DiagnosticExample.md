# Пример добавления своей диагностики

Диагностика - это класс, выполняющий анализ исходного кода для выявления проблемы или ошибки.

[DiagnosticStructure]:docs/contributing/DiagnosticStructure.md

## Содержимое диагностики (кратко)

В общем виде, для реализации диагностики необходимо создать несколько файлов

* Класс, реализуюий диагностику
* Два файла ресурсов (для английского и русского языка), содержащих название диагностики и сообщение об ошибке
* Файл фикстуры, содержащий BSL код, содержимое которого используется для тестирования диагностики
* Класс теста для дианостики
* Два файла (для английского и русского языка) с описанием диагностики, ее работы и параметров

Подробное описание содержимого файлов и правил использования находится в [статье][DiagnosticStructure].

## Создание диагностики

Ниже рассмотрен пример создания диагностики по мотивам уже созданной.

**Важно!**  
Перед созданием новой диагностики нужно убедиться, что ее еще никто другой не реализовывает в данный момент.

### Определение назначения диагностики

Перед реализацией новой диагностики, необходимо определить ее цель - какую ошибку (или недочет) необходимо обнаружить.

В качестве примера напишем диагностику, проверяющую наличие точки с запятой `;` в конце каждого выражения.

После определения цели, необходимо придумать уникальный ключ диагностики, под которым она будет добавлена в общий список. Ключ диагностики будет использоваться как базовая часть имени всех файлов диагностики.

Для создаваемой диагностики возьмем имя `SemicolonPresence`.

### Класс реализации диагностики

В каталоге `src/main/java` в пакете `org.github._1c_syntax.bsl.languageserver.diagnostics` надо создать файл класса диагностики. Имя файла образуется по принципу `%КлючДиагностики%` + `Diagnosctic.java`. В нашем примере это будет `SemicolonPresenceDiagnostic.java`.  

В файле необходимо создать одноименный класс, реализующий интерфейс `BSLDiagnostic`.  
Т.к. диагностика основывается на AST, то указываем наследование от класса `AbstractVisitorDiagnostic`, который в свою очередь реализует интерфейс `BSLDiagnostic`, но при этом имеет ряд расширений для простоты работы с AST.

В результате имеем следующее

```java
package org.github._1c_syntax.bsl.languageserver.diagnostics;

public class SemicolonPresenceDiagnostic extends AbstractVisitorDiagnostic {}
```

Каждая диагностика должна иметь аннотацию класса `@DiagnosticMetadata`, содержащую метаданные диагностики. Подробная информация об аннотациях в [статье][DiagnosticStructure].

В примере у нас реализуется диагностика, относящаяся к качеству кода (`CODE_SMELL`), низкого приоритета (`MINOR`), и требующая для исправления 1 минуту. Итоговый вид класса с аннотацией

```java
package org.github._1c_syntax.bsl.languageserver.diagnostics;

@DiagnosticMetadata(
  type = DiagnosticType.CODE_SMELL,
  severity = DiagnosticSeverity.MINOR,
  minutesToFix = 1
)
public class SemicolonPresenceDiagnostic extends AbstractVisitorDiagnostic {}
```

### Ресурсы класса

В каталоге `src/main/resources` в пакете `org.github._1c_syntax.bsl.languageserver.diagnostics` надо создать 2 файла ресурсов. Имена файлов образуется по принципу `%КлючДиагностики%` + `Diagnosctic_` + `%Язык%` + `.properties`.  
Проект поддерживает два языка: английский и русский, соответственно параметр `%Язык%` принимает значения `en` и `ru`.

В нашем примере будут файлы `SemicolonPresenceDiagnostic_ru.properties` и `SemicolonPresenceDiagnostic_en.properties`.  

В созданных файлах содержится (минимально) название диагностики (параметр `diagnosticName`) и сообщение замечания (`diagnosticMessage`).

В нашем примере содержимое файлов будет следующим

Файл `SemicolonPresenceDiagnostic_ru.properties`

```properties
diagnosticMessage=Пропущена точка с запятой в конце выражения
diagnosticName=Выражение должно заканчиваться ";"
```

Файл `SemicolonPresenceDiagnostic_en.properties`

```properties
diagnosticMessage=Missed semicolon at the end of statement
diagnosticName=Statement should end with ";"
```

### Фикстуры для теста

Для тестирования необходимо добавить в проект файл, содержщий примеры как ошибочного, так и корректного кода. Файл с фикстурами размещается в каталоге `src/test/resources` в пакете `diagnostics` с именем, образованным по `%КлючДиагностики%` + `Diagnosctic.bsl`. В нашем примере это будет `SemicolonPresenceDiagnostic.bsl`.  

В качестве данных для тестирвоания, внесем в файл следующий код

```bsl
А = 0;
Если Истина Тогда
  А = 0;
  А = 0           // Диагностика должна сработать здесь
КонецЕсли         // и здесь
```

**Внимание!**  
Стоит принять за правило выделение комментарями мест, где диагностика должна сработать.

### Написание теста

В каталоге `src/test/java` в пакете `org.github._1c_syntax.bsl.languageserver.diagnostics` надо создать файл тестового класса диагностики. Имя файла образуется по принципу `%КлючДиагностики%` + `DiagnoscticTest.java`. В нашем примере это будет `SemicolonPresenceDiagnosticTest.java`.  

В файле необходимо создать одноименный класс, унаследованый от класса `AbstractDiagnosticTest` для созданного класса диагностики.  
В результате имеем следующее

```java
package org.github._1c_syntax.bsl.languageserver.diagnostics;

class SemicolonPresenceDiagnosticTest extends AbstractDiagnosticTest<SemicolonPresenceDiagnostic>{
    SemicolonPresenceDiagnosticTest() {
        super(SemicolonPresenceDiagnostic.class);
    }
}
```

При написании тестов используется фреймворк [JUnit5](https://junit.org/junit5/), для утверждений используется библиотека [AssertJ](https://joel-costigliola.github.io/assertj/), предоставляющая [текучий/fluent-интерфейс](https://ru.wikipedia.org/wiki/Fluent_interface) "ожиданий", подобно привычной многим библиотеке [asserts](https://github.com/oscript-library/asserts) для [OneScript](http://oscript.io/).

Упрощенный базовый тест состоит из следующих шагов

* получение списка диагностик
* проверка количества срабатываний
* проверка местоположения срабатываний

Для добавления нового теста в созданный класс, необходимо добавить процедуру, аннотированную как тест `@Test`.

Не останавливаясь подробно, запоминаем, что

* Для получения диагностик по фикстуре используется метод `getDiagnostics()` реализованный в абстрактном классе `AbstractDiagnosticTest`. Он возвращает список сработавших диагностик текущего типа.
* Для проверки количество срабатываний необходимо проверить размер массива утверждением `hasSize`, куда передать количество ожидаемых элементов.
* Для проверки каждого обнаруженного элемента, необходимо сравнить найденный диапазон символов с ожидаемым, используя возможности класса `RangeHelper`.

Полученный класс теста выглядит следующим образом

```java
class SemicolonPresenceDiagnosticTest extends AbstractDiagnosticTest<SemicolonPresenceDiagnostic> {

  SemicolonPresenceDiagnosticTest() {
    super(SemicolonPresenceDiagnostic.class);
  }

  @Test
  void test() {
    List<Diagnostic> diagnostics = getDiagnostics(); // Получение диагностик

    assertThat(diagnostics).hasSize(2); // Проверка количества
    assertThat(diagnostics.get(0).getRange()).isEqualTo(RangeHelper.newRange(4, 0, 4, 9)); // Проверка конкретного случая
    assertThat(diagnostics.get(1).getRange()).isEqualTo(RangeHelper.newRange(3, 6, 3, 7)); // Проверка конкретного случая
  }
}
```

### Реализация диагностики

Проверку для диагностики, в большинстве случаев, можно реализовать с использованием подходящего `визитера AST`, в соответствии грамматикой языка, описанной в проекте [BSLParser](https://github.com/1c-syntax/bsl-parser/blob/master/src/main/antlr/BSLParser.g4).  
Согласно упомянутой грамматике, для нашего примера необходимо анализировать узлы с типом `statement`, следовательно используем визитер `visitStatement`. Каждый выбранный узел должен содержать конечный точку с запятой, представленную токеном `SEMICOLON`.

Таким образом, проверка будет состоять в том, чтобы в каждом узле `statement` найти токен `SEMICOLON`. Если токен не будет найден, то необходимо зарегистрировать замечание.

После реализации проверки, файл примет следующий вид

```java
package org.github._1c_syntax.bsl.languageserver.diagnostics;

@DiagnosticMetadata(
  type = DiagnosticType.CODE_SMELL,
  severity = DiagnosticSeverity.MINOR,
  minutesToFix = 1
)
public class SemicolonPresenceDiagnostic extends AbstractVisitorDiagnostic {

    @Override
    public ParseTree visitStatement(BSLParser.StatementContext ctx) { // выбранный визитер
        if (ctx.SEMICOLON() == null) {                                // получение дочернего узла SEMICOLON
            diagnosticStorage.addDiagnostic(ctx);                     // добавление замечания
        }
        // Для не-терминальных выражений в качестве возвращаемого значения
        // обязательно должен вызываться super-метод.
        return super.visitStatement(ctx);
    }

}
```

Необходимо запустить тест диагностики и убедиться в корректной работе.

**Отдельно стоит обратить внимание на `не-терминальные` выражения и использованием `super-метода` при возврате.**  
Если диагностика **не предусматривает** анализ вложенных блоков, то нужно сразу возвращать значение, не вызывая `super-метод`, что позволит сэкономить ресурсы на бессмылсенном вызове.  
Примеры:

* диагностика для метода или файла должна сразу возвращать значение, т.к. вложенных методов / файлов не существует
* диагностика для блока условия или области должна вызывать `super-метод`, т.к. они существуют и используются

### Создание описания диагностики

Для пользователького описания созданной диагностики, необходимо создать два файла: в каталоге `docs/diagnostics` на русском языке, в каталоге `docs/en/diagnostics` на английском языке.  
Имя файла образуется по принципу `%КлючДиагностики%` + `.md`. В нашем примере это будет `SemicolonPresence.md`.  

Файлы должны содержать подробное описание диагностики, примеры `правильно` и `не правильно`, ссылку на источники, если диагностика реализует проверку некотого стандарта, а также описание параметров диагностики. Важной частью описания является блок, описывающий недиагностируемые исключения.

В простом случае, файлы с описанием для русского и английского языков могут быть полностью идентичными и написаны на русском языке: перевод описаний перед релизом проекта для нелокализованных файлов будет выполнен с помощью сервиса [gitlocalize.com](gitlocalize.com).

## Завершение

После успешного тестирования диагностики, необходимо добавить ее в список реализованных диагностик проекта.  
Добавление происходит путем редактирования файлов `docs/index.md` для русского описания и `docs/en/index.md` для английского. В данных файлах присуствует раздел с таблицей реализованных диагностик, в который необходимо добавить свою, указав ее ключ, ссылку на соответствующий документ описания диагностики, название, а также активность по умолчанию _(по умолчанию все диагностики активны)_.
