{"version":"3","listProblem":[{
  "tool": "Code Inspection",
  "category": "Threading issues",
  "type": "Synchronization on a non-final field",
  "severity": "High",
  "comment": "Synchronization on a non-final field 'lock'",
  "detailsInfo": "Reports `synchronized` statement lock expressions that consist of a non-`final` field reference. Such statements are unlikely to have useful semantics, as different threads may acquire different locks even when operating on the same object.\n\n**Example:**\n\n\n      private Object o;\n      public void foo() {\n        synchronized (o) // synchronization on a non-final field\n        { }\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/cli/lsp/FileAwarePrintWriter.java",
      "language": "JAVA",
      "line": 65,
      "offset": 19,
      "length": 4,
      "code": {
        "startLine": 63,
        "length": 4,
        "offset": 131,
        "surroundingCode": "\n    // sync on non-private field, cause this#lock is supposed to be used as lock-object. See field description.\n    synchronized (lock) {\n      if (Objects.equals(file, this.file)) {\n        return;"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "SynchronizeOnNonFinalField"
  },
  "hash": "71510b63c026228016296af8bcabeb9928d46981295b1743fabe674d359834ff"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Mismatched read and write of array",
  "severity": "High",
  "comment": "Contents of array 'reportersOptions' are read, but never written to",
  "detailsInfo": "Reports arrays whose contents are read but not updated, or updated but not read. Such inconsistent reads and writes are pointless and probably indicate dead, incomplete or erroneous code.\n\n**Example:**\n\n\n      final int[] bar = new int[3];\n      bar[2] = 3;\n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/cli/AnalyzeCommand.java",
      "language": "JAVA",
      "line": 137,
      "offset": 20,
      "length": 16,
      "code": {
        "startLine": 135,
        "length": 16,
        "offset": 128,
        "surroundingCode": "    completionCandidates = ReportersKeys.class,\n    description = \"Reporter key (${COMPLETION-CANDIDATES})\")\n  private String[] reportersOptions = {};\n\n  @Option("
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "MismatchedArrayReadWrite"
  },
  "hash": "e23dc253d61398ae5cac8d40ded5019138a68b672262b608bb6c606167416647"
},{
  "tool": "Code Inspection",
  "category": "Declaration redundancy",
  "type": "Default annotation parameter value",
  "severity": "High",
  "comment": "Redundant default parameter value assignment",
  "detailsInfo": "Reports annotation parameters that are assigned to their `default` value.\n\nExample:\n\n\n      @interface Test {\n          Class<?> expected() default Throwable.class;\n      }\n\n      @Test(expected = Throwable.class)\n      void testSmth() {}\n\nAfter the quick-fix is applied:\n\n\n      @Test()\n      void testSmth() {}\n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/diagnostics/MissingSpaceDiagnostic.java",
      "language": "JAVA",
      "line": 88,
      "offset": 20,
      "length": 32,
      "code": {
        "startLine": 86,
        "length": 32,
        "offset": 68,
        "surroundingCode": "  @DiagnosticParameter(\n    type = String.class,\n    defaultValue = \"\" + DEFAULT_LIST_FOR_CHECK_LEFT\n  )\n  private String listForCheckLeft = DEFAULT_LIST_FOR_CHECK_LEFT;"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "DefaultAnnotationParam"
  },
  "hash": "e54d22da1df29d2d0b5068135afdbf35b6b42cd84636402376982a54bbc1f1ac"
},{
  "tool": "Code Inspection",
  "category": "Declaration redundancy",
  "type": "Default annotation parameter value",
  "severity": "High",
  "comment": "Redundant default parameter value assignment",
  "detailsInfo": "Reports annotation parameters that are assigned to their `default` value.\n\nExample:\n\n\n      @interface Test {\n          Class<?> expected() default Throwable.class;\n      }\n\n      @Test(expected = Throwable.class)\n      void testSmth() {}\n\nAfter the quick-fix is applied:\n\n\n      @Test()\n      void testSmth() {}\n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/diagnostics/BadWordsDiagnostic.java",
      "language": "JAVA",
      "line": 51,
      "offset": 20,
      "length": 17,
      "code": {
        "startLine": 49,
        "length": 17,
        "offset": 68,
        "surroundingCode": "  @DiagnosticParameter(\n    type = String.class,\n    defaultValue = BAD_WORDS_DEFAULT\n  )\n  private Pattern badWords = CaseInsensitivePattern.compile(BAD_WORDS_DEFAULT);"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "DefaultAnnotationParam"
  },
  "hash": "1cd580b858af24ae77df398d6173b43754b59023573376c9b9a35badfef2b455"
},{
  "tool": "Code Inspection",
  "category": "Verbose or redundant code constructs",
  "type": "Stream API call chain can be simplified",
  "severity": "High",
  "comment": "Can be replaced with 'peek'",
  "detailsInfo": "Reports stream API call chains that can be simplified. Simplification will often avoid some temporary object creation during collection traversal.\n\n\nThe inspection replaces the following call chains:\n\n* `collection.stream().forEach()` → `collection.forEach()`\n* `collection.stream().collect(toList/toSet/toCollection())` → `new CollectionType<>(collection)`\n* `collection.stream().toArray()` → `collection.toArray()`\n* `Arrays.asList().stream()` → `Arrays.stream()` or `Stream.of()`\n* `IntStream.range(0, array.length).mapToObj(idx -> array[idx])` → `Arrays.stream(array)`\n* `IntStream.range(0, list.size()).mapToObj(idx -> list.get(idx))` → `list.stream()`\n* `Collections.singleton().stream()` → `Stream.of()`\n* `Collections.emptyList().stream()` → `Stream.empty()`\n* `stream.filter().findFirst().isPresent()` → `stream.anyMatch()`\n* `stream.collect(counting())` → `stream.count()`\n* `stream.collect(maxBy())` → `stream.max()`\n* `stream.collect(mapping())` → `stream.map().collect()`\n* `stream.collect(reducing())` → `stream.reduce()`\n* `stream.collect(summingInt())` → `stream.mapToInt().sum()`\n* `stream.mapToObj(x -> x)` → `stream.boxed()`\n* `stream.map(x -> {...; return x;})` → `stream.peek(x -> ...)`\n* `!stream.anyMatch()` → `stream.noneMatch()`\n* `!stream.anyMatch(x -> !(...))` → `stream.allMatch()`\n* `stream.map().anyMatch(Boolean::booleanValue)` → `stream.anyMatch()`\n* `IntStream.range(expr1, expr2).mapToObj(x -> array[x])` → `Arrays.stream(array, expr1, expr2)`\n* `Collection.nCopies(count, ...)` → `Stream.generate().limit(count)`\n* `stream.sorted(comparator).findFirst()` → `Stream.min(comparator)`\n* `optional.orElseGet(() -> { throw new ...; })` → `optional.orElseThrow()`\n\n\nNote that the replacement semantics may have minor differences in some cases. For example,\n`Collections.synchronizedList(...).stream().forEach()` is not synchronized while\n`Collections.synchronizedList(...).forEach()` is synchronized.\nAlso, `collect(Collectors.maxBy())` returns an empty `Optional` if the resulting element is\n`null` while `Stream.max()` throws `NullPointerException` in this case.",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/diagnostics/ScheduledJobHandlerDiagnostic.java",
      "language": "JAVA",
      "line": 89,
      "offset": 8,
      "length": 3,
      "code": {
        "startLine": 87,
        "length": 3,
        "offset": 111,
        "surroundingCode": "    scheduledJobHandlers.values().stream()\n      .filter(mdScheduledJobs -> mdScheduledJobs.size() > 1)\n      .map((List<MDScheduledJob> mdScheduledJobs) -> {\n        mdScheduledJobs.sort(Comparator.comparing(AbstractMDObjectBase::getName));\n        return mdScheduledJobs;"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "SimplifyStreamApiCallChains"
  },
  "hash": "45cf4d9feeefe80fe2fbfd00066e8e8329a7a64dbd2950fa37a6c72f133ab6a4"
},{
  "tool": "Code Inspection",
  "category": "Threading issues",
  "type": "Field accessed in both 'synchronized' and unsynchronized contexts",
  "severity": "High",
  "comment": "Field 'isEmpty' is accessed in both synchronized and unsynchronized contexts",
  "detailsInfo": "Reports non-final fields that are accessed in both `synchronized` and non-`synchronized` contexts. `volatile` fields as well as accesses in constructors and initializers are ignored by this inspection.\n\n\nSuch \"partially synchronized\" access is often the result of a coding oversight\nand may lead to unexpectedly inconsistent data structures.\n\n**Example:**\n\n\n      public class Program {\n        Console console; // warning: Field 'console' is accessed in both synchronized and unsynchronized contexts\n\n        public synchronized void execute() {\n          console.print(\"running\");\n        }\n\n        public void check() {\n          console.check();\n        }\n      }\n\n\nUse the option to specify if simple getters and setters are counted as accesses too.",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/cli/lsp/FileAwarePrintWriter.java",
      "language": "JAVA",
      "line": 49,
      "offset": 19,
      "length": 7,
      "code": {
        "startLine": 47,
        "length": 7,
        "offset": 75,
        "surroundingCode": "public class FileAwarePrintWriter extends PrintWriter {\n\n  private boolean isEmpty = true;\n  private File file;\n"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "FieldAccessedSynchronizedAndUnsynchronized"
  },
  "hash": "8780740d1a34a0b0b9829350c1581750574ec4414f1b32654c87c25b0744da64"
},{
  "tool": "Code Inspection",
  "category": "RegExp",
  "type": "Redundant character escape",
  "severity": "High",
  "comment": "Redundant character escape '*' in RegExp",
  "detailsInfo": "Reports redundant character escape sequences that can be replaced with unescaped characters preserving the meaning. Many escape sequences that are necessary outside of a character class are redundant inside square brackets `[]` of a character class.\n\n\nAlthough unescaped opening curly braces `{` outside of character classes are allowed in some dialects (JavaScript, Python, and so on),\nit can cause confusion and make the pattern less portable, because there are dialects that require escaping curly braces as characters.\nFor this reason the inspection does not report escaped opening curly braces.\n\n**Example:**\n\n\n      \\-\\;[\\.]\n\nAfter the quick-fix is applied:\n\n\n      -;[.]\n\n\nThe **Ignore escaped closing brackets '}' and '\\]'** option specifies whether to report `\\}` and `\\]` outside of a character class\nwhen they are allowed to be unescaped by the RegExp dialect.\n\nNew in 2017.3",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/diagnostics/UsingHardcodeSecretInformationDiagnostic.java",
      "language": "RegExp",
      "line": 67,
      "offset": 76,
      "length": 3,
      "code": {
        "startLine": 65,
        "length": 3,
        "offset": 81,
        "surroundingCode": "  );\n\n  private static final Pattern PATTERN_CHECK_PASSWORD = Pattern.compile(\"^[\\\\*]+$\", Pattern.UNICODE_CASE);\n\n  @DiagnosticParameter("
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "RegExpRedundantEscape"
  },
  "hash": "6db027724eca46be1c37530db8747a3dd0031592cfb0e7dea684fd3808dc7669"
},{
  "tool": "Code Inspection",
  "category": "Verbose or redundant code constructs",
  "type": "Unnecessary 'continue' statement",
  "severity": "High",
  "comment": "'continue' is unnecessary as the last statement in a loop",
  "detailsInfo": "Reports `continue` statements if they are the last reachable statements in the loop. These `continue` statements are unnecessary and can be safely removed.\n\nExample:\n\n\n      for (String element: elements) {\n        System.out.println();\n        continue;\n      }\n\nAfter the quick-fix is applied:\n\n\n      for (String element: elements) {\n        System.out.println();\n      }\n\nThe inspection doesn't analyze JSP files.\n\n\nUse the **Ignore in then branch of 'if' statement with 'else' branch** option to ignore\n`continue` statements when they are placed in a `then` branch of a complete\n`if`-`else` statement.\n\nExample:\n\n\n      for (String element: elements) {\n        if(element.isEmpty()) {\n          continue;\n        } else {\n          //...\n        }\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/utils/expressiontree/ExpressionTreeBuildingVisitor.java",
      "language": "JAVA",
      "line": 86,
      "offset": 11,
      "length": 8,
      "code": {
        "startLine": 84,
        "length": 8,
        "offset": 144,
        "surroundingCode": "          visitMember((BSLParser.MemberContext) child);\n        } else if (child.getClass() == BSLParser.PreprocessorContext.class) {\n          continue;\n        } else {\n          throw new IllegalStateException();"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "UnnecessaryContinue"
  },
  "hash": "c70d70b6e7328acd0c64552167509c2554789136a5f6e56b42cbb9204a3e10c2"
},{
  "tool": "Code Inspection",
  "category": "Serialization issues",
  "type": "Non-serializable field in a 'Serializable' class",
  "severity": "High",
  "comment": "Non-serializable field 'exitPoint' in a Serializable class",
  "detailsInfo": "Reports non-serializable fields in classes that implement `java.io.Serializable`. Such fields will result in runtime exceptions if the object is serialized.\n\n\nFields declared\n`transient` or `static`\nare not reported, nor are fields of classes that have a `writeObject` method defined.\n\n\nThis inspection assumes fields of the types\n`java.util.Collection` and\n`java.util.Map` to be\n`Serializable`, unless the types\nthey are declared in are non-`Serializable`.\n\n**Example:**\n\n\n      class NonSerializableClass {}\n\n      public class SerializableClass implements Serializable {\n          NonSerializableClass clazz; // warning: Non-serializable field 'clazz' in a Serializable class\n          static NonSerializableClass staticClazz; // no warnings\n      }\n      \n\nUse the following options to configure the inspection:\n\n* List classes whose inheritors should not be reported by this inspection. This is meant for classes that inherit `Serializable` from a superclass but are not intended for serialization.\n* List annotations that will make the inspection ignore the annotated fields.\n* Whether to ignore fields initialized with an anonymous class.",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/cfg/ControlFlowGraph.java",
      "language": "JAVA",
      "line": 35,
      "offset": 22,
      "length": 9,
      "code": {
        "startLine": 33,
        "length": 9,
        "offset": 32,
        "surroundingCode": "\n  @Getter\n  private ExitVertex exitPoint;\n\n  ControlFlowGraph() {"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "NonSerializableFieldInSerializableClass"
  },
  "hash": "a330a052f7fb4db0324ec4ebc4b4aebd24031a56f77d397604f85b354d76f263"
},{
  "tool": "Code Inspection",
  "category": "Serialization issues",
  "type": "Non-serializable field in a 'Serializable' class",
  "severity": "High",
  "comment": "Non-serializable field 'compatibilityMode' in a Serializable class",
  "detailsInfo": "Reports non-serializable fields in classes that implement `java.io.Serializable`. Such fields will result in runtime exceptions if the object is serialized.\n\n\nFields declared\n`transient` or `static`\nare not reported, nor are fields of classes that have a `writeObject` method defined.\n\n\nThis inspection assumes fields of the types\n`java.util.Collection` and\n`java.util.Map` to be\n`Serializable`, unless the types\nthey are declared in are non-`Serializable`.\n\n**Example:**\n\n\n      class NonSerializableClass {}\n\n      public class SerializableClass implements Serializable {\n          NonSerializableClass clazz; // warning: Non-serializable field 'clazz' in a Serializable class\n          static NonSerializableClass staticClazz; // no warnings\n      }\n      \n\nUse the following options to configure the inspection:\n\n* List classes whose inheritors should not be reported by this inspection. This is meant for classes that inherit `Serializable` from a superclass but are not intended for serialization.\n* List annotations that will make the inspection ignore the annotated fields.\n* Whether to ignore fields initialized with an anonymous class.",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/diagnostics/metadata/DiagnosticCompatibilityMode.java",
      "language": "JAVA",
      "line": 54,
      "offset": 35,
      "length": 17,
      "code": {
        "startLine": 52,
        "length": 17,
        "offset": 39,
        "surroundingCode": "  ;\n\n  private final CompatibilityMode compatibilityMode;\n\n  DiagnosticCompatibilityMode(int minor, int version) {"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "NonSerializableFieldInSerializableClass"
  },
  "hash": "9bd9720fd9fe1e4cf2bec3d06a245d8a9f9ec06aa56b941bb143d551ad027ef7"
},{
  "tool": "Code Inspection",
  "category": "Declaration redundancy",
  "type": "'protected' member in 'final' class",
  "severity": "High",
  "comment": "Class member declared 'protected' in 'final' class",
  "detailsInfo": "Reports `protected` members in `final`classes.\n\nSince `final` classes cannot be inherited, marking the method as `protected`\nmay be confusing. It is better to declare such members as `private` or package-visible instead.\n\n**Example:**\n\n    record Bar(int a, int b) {\n      protected int sum() { \n         return a + b;\n      }\n    }\n\nAfter the quick-fix is applied:\n\n    record Bar(int a, int b) {\n      int sum() { \n         return a + b;\n      }\n    }\n\nAs shown in the example, a class can be marked as `final` explicitly or implicitly.",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/utils/expressiontree/TernaryOperatorNode.java",
      "language": "JAVA",
      "line": 40,
      "offset": 3,
      "length": 9,
      "code": {
        "startLine": 38,
        "length": 9,
        "offset": 30,
        "surroundingCode": "  BslExpression falsePart;\n\n  protected TernaryOperatorNode(BslExpression condition, BslExpression truePart, BslExpression falsePart) {\n    super(ExpressionNodeType.TERNARY_OP);\n    this.condition = condition;"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "ProtectedMemberInFinalClass"
  },
  "hash": "a6d80b534536073a4fb6262653b6f6d1e410126df2120e0d92bcc01ec12c4b9c"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant conditions & exceptions",
  "severity": "High",
  "comment": "Condition 'identifier != null' is always 'true'",
  "detailsInfo": "Reports code constructs that always produce the same result, may throw exceptions, or violates nullability contracts.\n\nExamples:\n\n    if (array.length < index) {\n      System.out.println(array[index]);\n    } // Array index is always out of bounds\n\n    if (str == null) System.out.println(\"str is null\");\n    System.out.println(str.trim());\n    // the last statement may throw an NPE\n\n    @NotNull\n    Integer square(@Nullable Integer input) {\n        // the method contract is violated\n        return input == null ? null : input * input;\n    }\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Suggest @Nullable annotation for methods/fields/parameters where nullable values are used** option to warn when a nullable value is passed as an argument to a method with a non-annotated parameter, stored into non-annotated field, or returned from a non-annotated method. In this case, the inspection will suggest propagating the `@Nullable` annotation. You can also configure nullability annotations using the **Configure Annotations** button.\n* Use the **Treat non-annotated members and parameters as @Nullable** option to assume that non-annotated members can be null, so they must not be used in non-null context.\n* Use the **Report not-null required parameter with null-literal argument usages** option to report method parameters that cannot be null (e.g. immediately dereferenced in the method body), but there are call sites where a `null` literal is passed.\n* Use the **Report nullable methods that always return a non-null value** option to report methods that are annotated as `@Nullable`, but always return non-null value. In this case, it's suggested that you change the annotation to `@NotNull`.\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when reading a value guaranteed to be constant** option to add warnings on reading variables that contain some constant values, for example: `true`, `false`, or `null`.\n* Use the **Report problems that happen only on some code paths** option to control whether to report problems that may happen only on some code path. If this option is disabled, warnings like *exception is possible* will not be reported. The inspection will report only warnings like *exception will definitely occur*. This mode may greatly reduce the number of false-positives, especially if the code is not consistently annotated with nullability and contract annotations. That is why it can be useful for finding the most important problems in legacy code bases.",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/diagnostics/UsingExternalCodeToolsDiagnostic.java",
      "language": "JAVA",
      "line": 72,
      "offset": 9,
      "length": 18,
      "code": {
        "startLine": 70,
        "length": 18,
        "offset": 103,
        "surroundingCode": "\n  private void checkUseExternalCodeTools(BSLParserRuleContext ctx, TerminalNode identifier) {\n    if (identifier != null\n      && externalCodeToolsName.matcher(identifier.getText()).matches()\n      && Trees.findAllRuleNodes(ctx, BSLParser.RULE_methodCall)"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "ConstantConditions"
  },
  "hash": "d3ae4f93d4a8a5344d8bc2d79c218c4459e69a26c9c7d8b3a3f8ba9c7670702c"
},{
  "tool": "Code Inspection",
  "category": "Inheritance issues",
  "type": "Abstract class which has no concrete subclass",
  "severity": "High",
  "comment": "Abstract class 'AbstractCfgVisitor' has no concrete subclass",
  "detailsInfo": "Reports `abstract` classes that have no concrete subclasses.",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/cfg/AbstractCfgVisitor.java",
      "language": "JAVA",
      "line": 32,
      "offset": 23,
      "length": 18,
      "code": {
        "startLine": 30,
        "length": 18,
        "offset": 63,
        "surroundingCode": " * конкретных узлов графа управления\n */\npublic abstract class AbstractCfgVisitor {\n\n  @FunctionalInterface"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "AbstractClassNeverImplemented"
  },
  "hash": "250f295ed1d99a3e34b62c1608641577216dc19ed5ba5ceeb0c3a1651a20a4ab"
},{
  "tool": "Code Inspection",
  "category": "Inheritance issues",
  "type": "Abstract class which has no concrete subclass",
  "severity": "High",
  "comment": "Abstract class 'ServerContext' has no concrete subclass",
  "detailsInfo": "Reports `abstract` classes that have no concrete subclasses.",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/context/ServerContext.java",
      "language": "JAVA",
      "line": 57,
      "offset": 23,
      "length": 13,
      "code": {
        "startLine": 55,
        "length": 13,
        "offset": 58,
        "surroundingCode": "@Component\n@RequiredArgsConstructor\npublic abstract class ServerContext {\n  private final Map<URI, DocumentContext> documents = Collections.synchronizedMap(new HashMap<>());\n  private final Lazy<Configuration> configurationMetadata = new Lazy<>(this::computeConfigurationMetadata);"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "AbstractClassNeverImplemented"
  },
  "hash": "ad0e7101efc0550c187172ef3eaf28d06e3a8a6d4fa974c31e7be3fef594b8e7"
},{
  "tool": "Code Inspection",
  "category": "Inheritance issues",
  "type": "Abstract class which has no concrete subclass",
  "severity": "High",
  "comment": "Abstract class 'DiagnosticComputer' has no concrete subclass",
  "detailsInfo": "Reports `abstract` classes that have no concrete subclasses.",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/context/computer/DiagnosticComputer.java",
      "language": "JAVA",
      "line": 39,
      "offset": 23,
      "length": 18,
      "code": {
        "startLine": 37,
        "length": 18,
        "offset": 54,
        "surroundingCode": "@RequiredArgsConstructor\n@Slf4j\npublic abstract class DiagnosticComputer {\n\n  public List<Diagnostic> compute(DocumentContext documentContext) {"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "AbstractClassNeverImplemented"
  },
  "hash": "a508c9d777c317e228c597aaf9c21e550b0364857c085c77a2affd1eb4dcbb06"
},{
  "tool": "Code Inspection",
  "category": "Inheritance issues",
  "type": "Abstract class which has no concrete subclass",
  "severity": "High",
  "comment": "Abstract class 'DiagnosticMixIn' has no concrete subclass",
  "detailsInfo": "Reports `abstract` classes that have no concrete subclasses.",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/reporters/databind/DiagnosticMixIn.java",
      "language": "JAVA",
      "line": 34,
      "offset": 23,
      "length": 15,
      "code": {
        "startLine": 32,
        "length": 15,
        "offset": 108,
        "surroundingCode": " * См. {@link com.fasterxml.jackson.databind.ObjectMapper#addMixIn(Class, Class)}\n */\npublic abstract class DiagnosticMixIn {\n\n  @JsonSerialize(using = DiagnosticCodeSerializer.class)"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "AbstractClassNeverImplemented"
  },
  "hash": "90b50e5f61f0466d344d0ee800056565883a508ec770e774a050442d08db423c"
},{
  "tool": "Code Inspection",
  "category": "Inheritance issues",
  "type": "Abstract class which has no concrete subclass",
  "severity": "High",
  "comment": "Abstract class 'DiagnosticsConfiguration' has no concrete subclass",
  "detailsInfo": "Reports `abstract` classes that have no concrete subclasses.",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/diagnostics/infrastructure/DiagnosticsConfiguration.java",
      "language": "JAVA",
      "line": 58,
      "offset": 23,
      "length": 24,
      "code": {
        "startLine": 56,
        "length": 24,
        "offset": 62,
        "surroundingCode": "@Configuration\n@RequiredArgsConstructor\npublic abstract class DiagnosticsConfiguration {\n\n  private final LanguageServerConfiguration configuration;"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "AbstractClassNeverImplemented"
  },
  "hash": "bc7c46b00be2e5d3ce721f09cbec59e932434e4f4c7229773a703574bd1139a4"
},{
  "tool": "Code Inspection",
  "category": "Lombok",
  "type": "@Qualifier not copyable by lombok",
  "severity": "High",
  "comment": "Lombok does not copy the annotation 'org.springframework.beans.factory.annotation.Qualifier' into the constructor",
  "detailsInfo": "Reports Spring `@Qualifier` annotations on class fields that are ignored by the corresponding Lombok `@RequiredArgsConstructor` and `@AllArgsConstructor` annotations. The generated constructors will not receive the `@Qualifier` annotation without a `lombok.copyableAnnotations` definition inside the `lombok.config` file.",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/reporters/ReportersAggregator.java",
      "language": "JAVA",
      "line": 43,
      "offset": 3,
      "length": 31,
      "code": {
        "startLine": 41,
        "length": 31,
        "offset": 16,
        "surroundingCode": "\n  @Autowired\n  @Qualifier(\"filteredReporters\")\n  @Lazy\n  // Don't remove @Autowired annotation. It's needed for injecting filteredReporters bean correctly."
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "SpringQualifierCopyableLombok"
  },
  "hash": "04085f7c5cec4361bb0d0b37131da1089051295ed971c2b35d37e940fafa99ea"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Cast conflicts with 'instanceof'",
  "severity": "High",
  "comment": "Cast to 'BSLParser.NewExpressionContext' type conflicts with preceding 'instanceof ParserRuleContext' check",
  "detailsInfo": "Reports type cast expressions that are preceded by an `instanceof` check for a different type.\n\n\nAlthough this might be intended, such a construct is most likely an error, and will\nresult in a `java.lang.ClassCastException` at runtime.\n\n**Example:**\n\n\n      class Main {\n        int whenCharSequenceCastToNumber(Object o){\n          if (o instanceof CharSequence) {\n            return ((Number) o).intValue();\n          }\n          return 0;\n        }\n\n        int earlyReturnWhenNotCharSequence(Object o){\n          if (!(o instanceof CharSequence)) return 0;\n          return ((Number)o).intValue();\n        }\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/diagnostics/NestedFunctionInParametersDiagnostic.java",
      "language": "JAVA",
      "line": 154,
      "offset": 47,
      "length": 34,
      "code": {
        "startLine": 152,
        "length": 34,
        "offset": 164,
        "surroundingCode": "        needReturn = true;\n      } else if (BSLParser.RULE_newExpression == ((ParserRuleContext) t).getRuleIndex()) {\n        needReturn = !emptyCallParameterList(((BSLParser.NewExpressionContext) t).doCall());\n      } else if (BSLParser.RULE_globalMethodCall == ((ParserRuleContext) t).getRuleIndex()) {\n        needReturn = !allowedMethodNamesPattern.matcher("
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "CastConflictsWithInstanceof"
  },
  "hash": "0a0da7fe1a6ed00365236044c5fbc049dae5efa5f00a853f80e3d8d65529c400"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Cast conflicts with 'instanceof'",
  "severity": "High",
  "comment": "Cast to 'BSLParser.GlobalMethodCallContext' type conflicts with preceding 'instanceof ParserRuleContext' check",
  "detailsInfo": "Reports type cast expressions that are preceded by an `instanceof` check for a different type.\n\n\nAlthough this might be intended, such a construct is most likely an error, and will\nresult in a `java.lang.ClassCastException` at runtime.\n\n**Example:**\n\n\n      class Main {\n        int whenCharSequenceCastToNumber(Object o){\n          if (o instanceof CharSequence) {\n            return ((Number) o).intValue();\n          }\n          return 0;\n        }\n\n        int earlyReturnWhenNotCharSequence(Object o){\n          if (!(o instanceof CharSequence)) return 0;\n          return ((Number)o).intValue();\n        }\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/diagnostics/NestedFunctionInParametersDiagnostic.java",
      "language": "JAVA",
      "line": 157,
      "offset": 12,
      "length": 37,
      "code": {
        "startLine": 155,
        "length": 37,
        "offset": 162,
        "surroundingCode": "      } else if (BSLParser.RULE_globalMethodCall == ((ParserRuleContext) t).getRuleIndex()) {\n        needReturn = !allowedMethodNamesPattern.matcher(\n          ((BSLParser.GlobalMethodCallContext) t).methodName().getText()).matches();\n      } else {\n        // no-op"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "CastConflictsWithInstanceof"
  },
  "hash": "0cd24cca234dcb0132ce8680a983be3892b65a8ba87c03fdc2f96441359eac8c"
},{
  "tool": "Code Inspection",
  "category": "Threading issues",
  "type": "Non-private field accessed in 'synchronized' context",
  "severity": "High",
  "comment": "Non-private field 'lock' accessed in synchronized context",
  "detailsInfo": "Reports non-`final`, non-`private` fields that are accessed in a synchronized context.\n\n\nA non-`private` field cannot be guaranteed to always be accessed in a synchronized manner, and such \"partially synchronized\"\naccess may result in unexpectedly inconsistent data structures.\n\n**Example:**\n\n\n      class Bar {\n        public String field1;\n      }\n      public Bar myBar;\n\n      synchronized public void sample() {\n       myBar.field1 = \"bar\";\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/cli/lsp/FileAwarePrintWriter.java",
      "language": "JAVA",
      "line": 65,
      "offset": 19,
      "length": 4,
      "code": {
        "startLine": 63,
        "length": 4,
        "offset": 131,
        "surroundingCode": "\n    // sync on non-private field, cause this#lock is supposed to be used as lock-object. See field description.\n    synchronized (lock) {\n      if (Objects.equals(file, this.file)) {\n        return;"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "PublicFieldAccessedInSynchronizedContext"
  },
  "hash": "b9cd696aed6a19477e5750c6176339b1e8882c3ae315fec182787d6f68688f9d"
},{
  "tool": "Code Inspection",
  "category": "Threading issues",
  "type": "Non-private field accessed in 'synchronized' context",
  "severity": "High",
  "comment": "Non-private field 'this.out' accessed in synchronized context",
  "detailsInfo": "Reports non-`final`, non-`private` fields that are accessed in a synchronized context.\n\n\nA non-`private` field cannot be guaranteed to always be accessed in a synchronized manner, and such \"partially synchronized\"\naccess may result in unexpectedly inconsistent data structures.\n\n**Example:**\n\n\n      class Bar {\n        public String field1;\n      }\n      public Bar myBar;\n\n      synchronized public void sample() {\n       myBar.field1 = \"bar\";\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/cli/lsp/FileAwarePrintWriter.java",
      "language": "JAVA",
      "line": 93,
      "offset": 7,
      "length": 8,
      "code": {
        "startLine": 91,
        "length": 8,
        "offset": 34,
        "surroundingCode": "      closeOutputStream();\n\n      this.out = new BufferedWriter(new OutputStreamWriter(fileOutputStream, StandardCharsets.UTF_8));\n      this.lock = this.out;\n      this.isEmpty = false;"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "PublicFieldAccessedInSynchronizedContext"
  },
  "hash": "b1fafb47d0d71b5a92a9523f880ea3fc5c41fb8cf8b85817f944b3772350c09d"
},{
  "tool": "Code Inspection",
  "category": "Threading issues",
  "type": "Non-private field accessed in 'synchronized' context",
  "severity": "High",
  "comment": "Non-private field 'this.lock' accessed in synchronized context",
  "detailsInfo": "Reports non-`final`, non-`private` fields that are accessed in a synchronized context.\n\n\nA non-`private` field cannot be guaranteed to always be accessed in a synchronized manner, and such \"partially synchronized\"\naccess may result in unexpectedly inconsistent data structures.\n\n**Example:**\n\n\n      class Bar {\n        public String field1;\n      }\n      public Bar myBar;\n\n      synchronized public void sample() {\n       myBar.field1 = \"bar\";\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/cli/lsp/FileAwarePrintWriter.java",
      "language": "JAVA",
      "line": 94,
      "offset": 7,
      "length": 9,
      "code": {
        "startLine": 92,
        "length": 9,
        "offset": 110,
        "surroundingCode": "\n      this.out = new BufferedWriter(new OutputStreamWriter(fileOutputStream, StandardCharsets.UTF_8));\n      this.lock = this.out;\n      this.isEmpty = false;\n    }"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "PublicFieldAccessedInSynchronizedContext"
  },
  "hash": "13f8a0c6fc69d593f935abf1b0b692d43b50cf16caff6898ed66510718171085"
},{
  "tool": "Code Inspection",
  "category": "Threading issues",
  "type": "Non-private field accessed in 'synchronized' context",
  "severity": "High",
  "comment": "Non-private field 'this.out' accessed in synchronized context",
  "detailsInfo": "Reports non-`final`, non-`private` fields that are accessed in a synchronized context.\n\n\nA non-`private` field cannot be guaranteed to always be accessed in a synchronized manner, and such \"partially synchronized\"\naccess may result in unexpectedly inconsistent data structures.\n\n**Example:**\n\n\n      class Bar {\n        public String field1;\n      }\n      public Bar myBar;\n\n      synchronized public void sample() {\n       myBar.field1 = \"bar\";\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/cli/lsp/FileAwarePrintWriter.java",
      "language": "JAVA",
      "line": 94,
      "offset": 19,
      "length": 8,
      "code": {
        "startLine": 92,
        "length": 8,
        "offset": 122,
        "surroundingCode": "\n      this.out = new BufferedWriter(new OutputStreamWriter(fileOutputStream, StandardCharsets.UTF_8));\n      this.lock = this.out;\n      this.isEmpty = false;\n    }"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "PublicFieldAccessedInSynchronizedContext"
  },
  "hash": "f111af7068dfc76ca7c9d16705fc326b4ea11cea756d746bf7a54199352e8268"
},{
  "tool": "Code Inspection",
  "category": "Class structure",
  "type": "Utility class with 'public' constructor",
  "severity": "High",
  "comment": "Class 'BSLLSBinding' has only 'static' members, and a 'public' constructor",
  "detailsInfo": "Reports utility classes with `public` constructors.\n\nUtility classes have all fields and methods declared as `static`. Creating a `public`\nconstructor in such classes is confusing and may cause accidental class instantiation.",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/BSLLSBinding.java",
      "language": "JAVA",
      "line": 43,
      "offset": 14,
      "length": 12,
      "code": {
        "startLine": 41,
        "length": 12,
        "offset": 97,
        "surroundingCode": "@EnableAutoConfiguration\n@ComponentScan(\"com.github._1c_syntax.bsl.languageserver\")\npublic class BSLLSBinding {\n\n  @Getter(lazy = true, value = AccessLevel.PRIVATE)"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "UtilityClassWithPublicConstructor"
  },
  "hash": "2c148ff0fe1e588079873203724019e5e6ca93a51f0882c21988a94471e1733b"
}]}