{"version":"3","listProblem":[{
  "tool": "Code Inspection",
  "category": "Visibility",
  "type": "Class is exposed outside of its visibility scope",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Class 'GenericIssueEntry' is exposed outside its defined visibility scope",
  "detailsInfo": "Reports usages of classes in a field or method signature where the class has less visibility than the member that uses it. While legal Java, such members cannot be used outside of the visibility scope of the class type they reference.\n\n**Example:**\n\n\n      public class Parent {\n        public Child getChild() {\n          return new Child();\n        }\n\n        private class Child {}\n      }\n\n\nAdditionally, in Java 9 and higher, a module may hide some of its classes from other modules by not exporting their packages.\nHowever, if a member that is part of the exported API references a non-exported class in its signature,\nsuch a member cannot be used outside of the module.\n\nConfigure the inspection:\n\n* Use the **Report non-exported classes exposed in module API (Java 9+)** option to report module API members that expose non-exported classes.  \n  Note that the language level of the project or module needs to be 9 or higher for this option.\n* Use the **Report non-accessible classes exposed in public API** option to report on public members that expose classes with a smaller visibility scope.\n* Use the **Report private classes exposed in package-local API** option to report on package-local members that expose `private` classes.",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/reporters/GenericIssueReport.java",
      "language": "JAVA",
      "line": 58,
      "offset": 34,
      "length": 17,
      "code": {
        "startLine": 56,
        "length": 17,
        "offset": 63,
        "surroundingCode": "\n  public GenericIssueReport(\n    @JsonProperty(\"issues\") List<GenericIssueEntry> issues\n  ) {\n    this.issues = new ArrayList<>(issues);"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "ClassEscapesItsScope"
  },
  "hash": "45ccd9fa2238b4548fda47db28982a92175a4a04183a2eb2a6f188ece5252ea2"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "Moderate",
  "comment": "Value 'mode' is always 'null'",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/diagnostics/infrastructure/DiagnosticsConfiguration.java",
      "language": "JAVA",
      "line": 180,
      "offset": 24,
      "length": 4,
      "code": {
        "startLine": 178,
        "length": 4,
        "offset": 184,
        "surroundingCode": "    boolean passedOnlyMode = mode == Mode.ONLY && hasDefinedSetting;\n    boolean passedExcept = mode == Mode.EXCEPT && !(hasDefinedSetting || disabledDirectly);\n    boolean passedOn = mode == Mode.ON && (activatedByDefault || hasDefinedSetting);\n\n    return passedOn"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "0bdcb06221402bea15c6f36151f032baba11faef0cccef907a77371779bf05fe"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Condition 'mode == Mode.ONLY && hasDefinedSetting' is always 'false'",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/diagnostics/infrastructure/DiagnosticsConfiguration.java",
      "language": "JAVA",
      "line": 178,
      "offset": 30,
      "length": 38,
      "code": {
        "startLine": 176,
        "length": 38,
        "offset": 76,
        "surroundingCode": "\n    boolean passedAllMode = mode == Mode.ALL;\n    boolean passedOnlyMode = mode == Mode.ONLY && hasDefinedSetting;\n    boolean passedExcept = mode == Mode.EXCEPT && !(hasDefinedSetting || disabledDirectly);\n    boolean passedOn = mode == Mode.ON && (activatedByDefault || hasDefinedSetting);"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "0eea6bfdc9704797259678b6e2796454b80591449c3b7390385602d8e2138ee7"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "Moderate",
  "comment": "Value 'range' is always 'null'",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/diagnostics/SetPermissionsForNewObjectsDiagnostic.java",
      "language": "JAVA",
      "line": 75,
      "offset": 78,
      "length": 5,
      "code": {
        "startLine": 73,
        "length": 5,
        "offset": 166,
        "surroundingCode": "      .filter(Predicate.not(namesFullAccessRole::contains))\n      .map(info::getMessage)\n      .forEach((String diagnosticMessage) -> diagnosticStorage.addDiagnostic(range, diagnosticMessage)\n      );\n  }"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "14ec93d923941334fb8f925db420d715606a76a8fbd1d524d603180398fde625"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "Moderate",
  "comment": "Value 'searchableLeft' is always 'null'",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/diagnostics/IdenticalExpressionsDiagnostic.java",
      "language": "JAVA",
      "line": 136,
      "offset": 29,
      "length": 14,
      "code": {
        "startLine": 134,
        "length": 14,
        "offset": 135,
        "surroundingCode": "      while (true) {\n        var equal = comparer.areEqual(searchableLeft, complementaryNode.getLeft()) ||\n          comparer.areEqual(searchableLeft, complementaryNode.getRight());\n\n        if (equal) {"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "1542105e672ffaaea9e3b9634dce3f754c8d5b5b044ff5d4824daeda324a17ff"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Condition 'mode == Mode.EXCEPT' is always 'false'",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/diagnostics/infrastructure/DiagnosticsConfiguration.java",
      "language": "JAVA",
      "line": 179,
      "offset": 28,
      "length": 19,
      "code": {
        "startLine": 177,
        "length": 19,
        "offset": 142,
        "surroundingCode": "    boolean passedAllMode = mode == Mode.ALL;\n    boolean passedOnlyMode = mode == Mode.ONLY && hasDefinedSetting;\n    boolean passedExcept = mode == Mode.EXCEPT && !(hasDefinedSetting || disabledDirectly);\n    boolean passedOn = mode == Mode.ON && (activatedByDefault || hasDefinedSetting);\n"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "1569da877f3d226e31a2227be253b613bac3c01de5b81a14f2a8c67d574dd5b3"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "Moderate",
  "comment": "Value 'range' is always 'null'",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/diagnostics/CommonModuleMissingAPIDiagnostic.java",
      "language": "JAVA",
      "line": 76,
      "offset": 24,
      "length": 5,
      "code": {
        "startLine": 74,
        "length": 5,
        "offset": 84,
        "surroundingCode": "\n    var range = symbolTree.getModule().getSelectionRange();\n    if (Ranges.isEmpty(range)) {\n      return;\n    }"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "15f44d541b27573c4bc74ef37461832461f63f7d6bc78f0a1bc7ebed1f6fbf1e"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "Moderate",
  "comment": "Value 'operator' is always 'null'",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/utils/expressiontree/TransitiveOperationsIgnoringComparer.java",
      "language": "JAVA",
      "line": 42,
      "offset": 31,
      "length": 8,
      "code": {
        "startLine": 40,
        "length": 8,
        "offset": 71,
        "surroundingCode": "\n    var operator = first.getOperator();\n    if (isTransitiveOperation(operator)) {\n      return super.binaryOperationsEqual(first, second) ||\n        (areEqual(first.getLeft(), second.getRight()) && areEqual(first.getRight(), second.getLeft()));"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "169743ee81a818a0541f9109ce987c7bb6354592580281502a82db87104a6349"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Condition 'configuredSkipSupport != SkipSupport.WITH_SUPPORT' is always 'true'",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/diagnostics/infrastructure/DiagnosticsConfiguration.java",
      "language": "JAVA",
      "line": 154,
      "offset": 12,
      "length": 49,
      "code": {
        "startLine": 152,
        "length": 49,
        "offset": 18,
        "surroundingCode": "    }\n\n    return configuredSkipSupport != SkipSupport.WITH_SUPPORT;\n  }\n"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "1d607167324f450c77d406ea4040e630640a5c04722e8da34e5b4ef32d88256c"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Condition 'passedOnlyMode' is always 'false'",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/diagnostics/infrastructure/DiagnosticsConfiguration.java",
      "language": "JAVA",
      "line": 184,
      "offset": 10,
      "length": 14,
      "code": {
        "startLine": 182,
        "length": 14,
        "offset": 52,
        "surroundingCode": "    return passedOn\n      || passedAllMode\n      || passedOnlyMode\n      || passedExcept\n      ;"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "21bd43b030a27e116e710a997e627b5b051c338b5b5f1a3774d4b434fc5f6e93"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "Moderate",
  "comment": "Value 'symbol' is always 'null'",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/references/ReferenceIndex.java",
      "language": "JAVA",
      "line": 187,
      "offset": 15,
      "length": 6,
      "code": {
        "startLine": 185,
        "length": 6,
        "offset": 116,
        "surroundingCode": "    var symbolOccurrence = SymbolOccurrence.builder()\n      .occurrenceType(OccurrenceType.REFERENCE)\n      .symbol(symbol)\n      .location(location)\n      .build();"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "23692f57e7e245dafeae76d5046eb1b104a845cf0af2337014719946a06689d7"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "Moderate",
  "comment": "Value 'range' is always 'null'",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/diagnostics/OrdinaryAppSupportDiagnostic.java",
      "language": "JAVA",
      "line": 61,
      "offset": 25,
      "length": 5,
      "code": {
        "startLine": 59,
        "length": 5,
        "offset": 106,
        "surroundingCode": "\n    var range = documentContext.getSymbolTree().getModule().getSelectionRange();\n    if (!Ranges.isEmpty(range)) {\n      checkProperties(range);\n    }"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "23886bd230833640a6d7b66506cfc3af0531e9e874d50e2a119bcb7351155498"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "Moderate",
  "comment": "Value 'operator' is always 'null'",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/diagnostics/IdenticalExpressionsDiagnostic.java",
      "language": "JAVA",
      "line": 248,
      "offset": 13,
      "length": 8,
      "code": {
        "startLine": 246,
        "length": 8,
        "offset": 80,
        "surroundingCode": "\n        // одинаковые умножения и сложения - не считаем, см. тесты\n        if (operator != BslOperator.ADD && operator != BslOperator.MULTIPLY) {\n          list.add(binary);\n        }"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "3284df7d0fecc15a691e27dff656ba22d67a73366dcf0dd3002644ce75d1e10a"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "Moderate",
  "comment": "Value 'callNode' is always 'null'",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/utils/expressiontree/ExpressionTreeBuildingVisitor.java",
      "language": "JAVA",
      "line": 361,
      "offset": 22,
      "length": 8,
      "code": {
        "startLine": 359,
        "length": 8,
        "offset": 140,
        "surroundingCode": "    var methodCall = ctx.methodCall();\n    var callNode = MethodCallNode.create(methodCall.methodName().IDENTIFIER());\n    addCallArguments(callNode, methodCall.doCall().callParamList().callParam());\n    var operation = BinaryOperationNode.create(BslOperator.DEREFERENCE, target, callNode, ctx);\n    operands.push(operation);"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "335971b1d0f116d1074f0c57da4024f04c56f01bc32bc6d60c95cde9bcf2ca0e"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Condition 'operator != BslOperator.MULTIPLY' is always 'true' when reached",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/diagnostics/IdenticalExpressionsDiagnostic.java",
      "language": "JAVA",
      "line": 248,
      "offset": 44,
      "length": 32,
      "code": {
        "startLine": 246,
        "length": 32,
        "offset": 111,
        "surroundingCode": "\n        // одинаковые умножения и сложения - не считаем, см. тесты\n        if (operator != BslOperator.ADD && operator != BslOperator.MULTIPLY) {\n          list.add(binary);\n        }"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "33cef6b8fe35835e75201becd8d147f479aa3772e23a4372922d6dff0b74350d"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "Moderate",
  "comment": "Value 'uri' is always 'null'",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/diagnostics/DeprecatedMethodCallDiagnostic.java",
      "language": "JAVA",
      "line": 55,
      "offset": 38,
      "length": 3,
      "code": {
        "startLine": 53,
        "length": 3,
        "offset": 78,
        "surroundingCode": "    var uri = documentContext.getUri();\n\n    referenceIndex.getReferencesFrom(uri, SymbolKind.Method).stream()\n      .filter(reference -> reference.getSymbol().isDeprecated())\n      .filter(reference -> !reference.getFrom().isDeprecated())"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "36c53122d0d18700b58019245ced90f33db62fd1d4a5576a6288faf4c7a2b743"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "Moderate",
  "comment": "Value 'configuredSkipSupport' is always 'null'",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/diagnostics/infrastructure/DiagnosticsConfiguration.java",
      "language": "JAVA",
      "line": 150,
      "offset": 9,
      "length": 21,
      "code": {
        "startLine": 148,
        "length": 21,
        "offset": 15,
        "surroundingCode": "    }\n\n    if (configuredSkipSupport == SkipSupport.WITH_SUPPORT_LOCKED) {\n      return moduleSupportVariant != SupportVariant.NOT_EDITABLE;\n    }"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "37cb0b70d24c90a0a3a6d714d9813fe9b356f64baa9feae4fe3bb4860ed483e7"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Condition 'operator == BslOperator.INDEX_ACCESS' is always 'false' when reached",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/diagnostics/IdenticalExpressionsDiagnostic.java",
      "language": "JAVA",
      "line": 243,
      "offset": 52,
      "length": 36,
      "code": {
        "startLine": 241,
        "length": 36,
        "offset": 176,
        "surroundingCode": "        // разыменования отбросим, хотя comparer их и не зачтет, но для производительности\n        // лучше выкинем их сразу\n        if (operator == BslOperator.DEREFERENCE || operator == BslOperator.INDEX_ACCESS) {\n          return;\n        }"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "3affe1bd13a80bb30baba4ce5e002bf2dc4f25da2c90b6ef16a7088b71e2ffb9"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "Moderate",
  "comment": "Value 'range' is always 'null'",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/diagnostics/AbstractCommonModuleNameDiagnostic.java",
      "language": "JAVA",
      "line": 47,
      "offset": 24,
      "length": 5,
      "code": {
        "startLine": 45,
        "length": 5,
        "offset": 131,
        "surroundingCode": "  protected void check() {\n    var range = documentContext.getSymbolTree().getModule().getSelectionRange();\n    if (Ranges.isEmpty(range)) {\n      return;\n    }"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "3c390397b74c88cfe856e637b86aff9ea489e2565d3baf17403285f41abe55c2"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Condition 'Ranges.isEmpty(range)' is always 'false'",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/diagnostics/CommonModuleMissingAPIDiagnostic.java",
      "language": "JAVA",
      "line": 76,
      "offset": 9,
      "length": 21,
      "code": {
        "startLine": 74,
        "length": 21,
        "offset": 69,
        "surroundingCode": "\n    var range = symbolTree.getModule().getSelectionRange();\n    if (Ranges.isEmpty(range)) {\n      return;\n    }"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "3caf4733165590dadeb5a7c85efffe5e770ccb240f6b9c0f1084d9f407323ec0"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "Moderate",
  "comment": "Value 'range' is always 'null'",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/diagnostics/SetPermissionsForNewObjectsDiagnostic.java",
      "language": "JAVA",
      "line": 66,
      "offset": 24,
      "length": 5,
      "code": {
        "startLine": 64,
        "length": 5,
        "offset": 128,
        "surroundingCode": "  public void check() {\n    var range = documentContext.getSymbolTree().getModule().getSelectionRange();\n    if (Ranges.isEmpty(range)) {\n      return;\n    }"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "42426310bf5009ee89b7364187f6472b2a3201142fccab608a4bbb9ea27b43f9"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Condition 'operator == BslOperator.OR' is always 'false'",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/diagnostics/IdenticalExpressionsDiagnostic.java",
      "language": "JAVA",
      "line": 263,
      "offset": 10,
      "length": 26,
      "code": {
        "startLine": 261,
        "length": 26,
        "offset": 121,
        "surroundingCode": "  private static boolean isComplementary(BinaryOperationNode binary) {\n    var operator = binary.getOperator();\n    if ((operator == BslOperator.OR || operator == BslOperator.AND)\n      && binary.getRight() instanceof BinaryOperationNode) {\n      return ((BinaryOperationNode) binary.getRight()).getOperator() == operator;"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "4643c4046204fe5d91a254887d05b9f6994513719055c38358493ec54e90e656"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "Moderate",
  "comment": "Value 'language' is always 'null'",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/reporters/SarifReporter.java",
      "language": "JAVA",
      "line": 187,
      "offset": 21,
      "length": 8,
      "code": {
        "startLine": 185,
        "length": 8,
        "offset": 90,
        "surroundingCode": "      .withVersion(version)\n      .withInformationUri(informationUri)\n      .withLanguage(language)\n      .withRules(rules);\n"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "464fd4ccf007e36d6d2585df1e1e70e4752a0f62d8374a31fda159db5c155030"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "Moderate",
  "comment": "Value 'symbol' is always 'null'",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/references/ReferenceIndex.java",
      "language": "JAVA",
      "line": 229,
      "offset": 15,
      "length": 6,
      "code": {
        "startLine": 227,
        "length": 6,
        "offset": 157,
        "surroundingCode": "    var symbolOccurrence = SymbolOccurrence.builder()\n      .occurrenceType(definition ? OccurrenceType.DEFINITION : OccurrenceType.REFERENCE)\n      .symbol(symbol)\n      .location(location)\n      .build();"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "46d854e24d188209ce0e0e9d4b0ded6ba769e0d538ced5c31881294416dd3aca"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "Moderate",
  "comment": "Value 'configuredSkipSupport' is always 'null'",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/diagnostics/infrastructure/DiagnosticsConfiguration.java",
      "language": "JAVA",
      "line": 154,
      "offset": 12,
      "length": 21,
      "code": {
        "startLine": 152,
        "length": 21,
        "offset": 18,
        "surroundingCode": "    }\n\n    return configuredSkipSupport != SkipSupport.WITH_SUPPORT;\n  }\n"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "488f1e6022d432e860ac5aebd1a0ba7182ae13ee7e3f57d3218cc7bb0e7e12cc"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Condition 'configuredSkipSupport == SkipSupport.WITH_SUPPORT_LOCKED' is always 'false'",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/diagnostics/infrastructure/DiagnosticsConfiguration.java",
      "language": "JAVA",
      "line": 150,
      "offset": 9,
      "length": 56,
      "code": {
        "startLine": 148,
        "length": 56,
        "offset": 15,
        "surroundingCode": "    }\n\n    if (configuredSkipSupport == SkipSupport.WITH_SUPPORT_LOCKED) {\n      return moduleSupportVariant != SupportVariant.NOT_EDITABLE;\n    }"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "4c3d02dc8c6890d0eb9c3ef1ca170681547139e0b174ebb31b29225fded33114"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Condition 'operator == BslOperator.OR || operator == BslOperator.AND' is always 'false'",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/diagnostics/IdenticalExpressionsDiagnostic.java",
      "language": "JAVA",
      "line": 263,
      "offset": 10,
      "length": 57,
      "code": {
        "startLine": 261,
        "length": 57,
        "offset": 121,
        "surroundingCode": "  private static boolean isComplementary(BinaryOperationNode binary) {\n    var operator = binary.getOperator();\n    if ((operator == BslOperator.OR || operator == BslOperator.AND)\n      && binary.getRight() instanceof BinaryOperationNode) {\n      return ((BinaryOperationNode) binary.getRight()).getOperator() == operator;"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "5150c83b37a2c9ad22eb7e3a93f44d57de9b7438237e3654eeab66f358b9fbfc"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "Moderate",
  "comment": "Value 'needFormatKeyword' is always 'null'",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/providers/FormatProvider.java",
      "language": "JAVA",
      "line": 332,
      "offset": 9,
      "length": 17,
      "code": {
        "startLine": 330,
        "length": 17,
        "offset": 191,
        "surroundingCode": "  private String checkAndFormatKeyword(Token token, Locale languageLocale) {\n    var needFormatKeyword = languageServerConfiguration.getFormattingOptions().isUseKeywordsFormatting();\n    if (needFormatKeyword) {\n      return keywordCanonText.get(languageLocale).getOrDefault(token.getType(), token.getText());\n    }"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "532103fcd80cac66361557def658f1eb9e491dceb9de3e0a50dce308d39ea495"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Condition 'operator != BslOperator.ADD' is always 'true'",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/diagnostics/IdenticalExpressionsDiagnostic.java",
      "language": "JAVA",
      "line": 248,
      "offset": 13,
      "length": 27,
      "code": {
        "startLine": 246,
        "length": 27,
        "offset": 80,
        "surroundingCode": "\n        // одинаковые умножения и сложения - не считаем, см. тесты\n        if (operator != BslOperator.ADD && operator != BslOperator.MULTIPLY) {\n          list.add(binary);\n        }"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "552f7c66f5f5260b401e118e3c40d4a9b7a5d79dbabbefa24fe6576536ea357e"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "Moderate",
  "comment": "Value 'operator' is always 'null'",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/diagnostics/IdenticalExpressionsDiagnostic.java",
      "language": "JAVA",
      "line": 243,
      "offset": 52,
      "length": 8,
      "code": {
        "startLine": 241,
        "length": 8,
        "offset": 176,
        "surroundingCode": "        // разыменования отбросим, хотя comparer их и не зачтет, но для производительности\n        // лучше выкинем их сразу\n        if (operator == BslOperator.DEREFERENCE || operator == BslOperator.INDEX_ACCESS) {\n          return;\n        }"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "58553d4fccf64b7a2d19e0ac2c84f5ccfffb8ed10e86fc366944c9f92e83734e"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Condition 'mode == Mode.ONLY' is always 'false'",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/diagnostics/infrastructure/DiagnosticsConfiguration.java",
      "language": "JAVA",
      "line": 178,
      "offset": 30,
      "length": 17,
      "code": {
        "startLine": 176,
        "length": 17,
        "offset": 76,
        "surroundingCode": "\n    boolean passedAllMode = mode == Mode.ALL;\n    boolean passedOnlyMode = mode == Mode.ONLY && hasDefinedSetting;\n    boolean passedExcept = mode == Mode.EXCEPT && !(hasDefinedSetting || disabledDirectly);\n    boolean passedOn = mode == Mode.ON && (activatedByDefault || hasDefinedSetting);"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "58d1924a0d685ef33b2f0504c08529e5e440ee4b708c8563133ef87a62bba813"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "Moderate",
  "comment": "Value 'isModuleWithoutExportSub' is always 'null'",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/diagnostics/CommonModuleMissingAPIDiagnostic.java",
      "language": "JAVA",
      "line": 89,
      "offset": 9,
      "length": 24,
      "code": {
        "startLine": 87,
        "length": 24,
        "offset": 50,
        "surroundingCode": "      .noneMatch(REGION_NAME::contains);\n\n    if (isModuleWithoutExportSub || isModuleWithoutRegionAPI) {\n      diagnosticStorage.addDiagnostic(range);\n    }"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "5a0b3e632dba6b57b944c0d244cc18b2ac70072725be8d28d7441fc5b881cfa5"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "Moderate",
  "comment": "Value 'mode' is always 'null'",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/diagnostics/infrastructure/DiagnosticsConfiguration.java",
      "language": "JAVA",
      "line": 179,
      "offset": 28,
      "length": 4,
      "code": {
        "startLine": 177,
        "length": 4,
        "offset": 142,
        "surroundingCode": "    boolean passedAllMode = mode == Mode.ALL;\n    boolean passedOnlyMode = mode == Mode.ONLY && hasDefinedSetting;\n    boolean passedExcept = mode == Mode.EXCEPT && !(hasDefinedSetting || disabledDirectly);\n    boolean passedOn = mode == Mode.ON && (activatedByDefault || hasDefinedSetting);\n"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "5c6cdfaed91fe53ef3de0f9bbbfef53f82fac9692aac80996c41afa47811b7f5"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "Moderate",
  "comment": "Value 'ast' is always 'null'",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/inlayhints/SourceDefinedMethodCallInlayHintSupplier.java",
      "language": "JAVA",
      "line": 94,
      "offset": 42,
      "length": 3,
      "code": {
        "startLine": 92,
        "length": 3,
        "offset": 97,
        "surroundingCode": "\n    var ast = reference.getFrom().getOwner().getAst();\n    var doCalls = Trees.findAllRuleNodes(ast, BSLParser.RULE_doCall);\n\n    return doCalls.stream()"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "5ce31c8f9273fe0ee1198e490e029b92cd2efc7135b98ff983658689c0cd61f2"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "Moderate",
  "comment": "Value 'parameterName' is always 'null'",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/hover/MethodSymbolMarkupContentBuilder.java",
      "language": "JAVA",
      "line": 224,
      "offset": 20,
      "length": 13,
      "code": {
        "startLine": 222,
        "length": 13,
        "offset": 93,
        "surroundingCode": "        parameter = parameter + getResourceString(VAL_KEY) + \" \";\n      }\n      parameter += parameterName;\n\n      var parameterTypes = parameterDefinition.getDescription()"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "6119f50e88312d90225d162b9e55eaece35df7cc8c85efa0c708f37eaa7ee15b"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "Moderate",
  "comment": "Value 'configuredMode' is always 'null'",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/diagnostics/infrastructure/DiagnosticsConfiguration.java",
      "language": "JAVA",
      "line": 131,
      "offset": 9,
      "length": 14,
      "code": {
        "startLine": 129,
        "length": 14,
        "offset": 64,
        "surroundingCode": "    var configuredMode = diagnosticsOptions.getMode();\n\n    if (configuredMode == Mode.OFF) {\n      return false;\n    }"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "6178e4763e569e9e5bf2c400b65abb09cd0c24a722388dc3438ba8261eb8bbc6"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "Moderate",
  "comment": "Value 'test' is always 'null'",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/jmh/java/com/github/_1c_syntax/bsl/languageserver/context/symbol/VariableSymbolCreate.java",
      "language": "JAVA",
      "line": 67,
      "offset": 16,
      "length": 4,
      "code": {
        "startLine": 65,
        "length": 4,
        "offset": 44,
        "surroundingCode": "      .scope(null).build();\n\n    bh.consume(test);\n  }\n"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.jmh",
    "inspectionName": "ConstantValue"
  },
  "hash": "6622d6f06c7893521e1b3e77a5792d0f22731ce7184a4ddfae6e49a7a5936f85"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "Moderate",
  "comment": "Value 'uri' is always 'null'",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/references/ReferenceIndex.java",
      "language": "JAVA",
      "line": 276,
      "offset": 85,
      "length": 3,
      "code": {
        "startLine": 274,
        "length": 3,
        "offset": 158,
        "surroundingCode": "    var position = symbolOccurrence.getLocation().getRange().getStart();\n\n    Optional<SymbolTree> symbolTree = Optional.ofNullable(serverContext.getDocument(uri))\n      .map(DocumentContext::getSymbolTree);\n    return symbolTree"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "6887354a9ee4cd65b108b4aff7f291af4ebd162d0256075d828ff292d8bc490c"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Condition 'mode == Mode.ON' is always 'false'",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/diagnostics/infrastructure/DiagnosticsConfiguration.java",
      "language": "JAVA",
      "line": 180,
      "offset": 24,
      "length": 15,
      "code": {
        "startLine": 178,
        "length": 15,
        "offset": 184,
        "surroundingCode": "    boolean passedOnlyMode = mode == Mode.ONLY && hasDefinedSetting;\n    boolean passedExcept = mode == Mode.EXCEPT && !(hasDefinedSetting || disabledDirectly);\n    boolean passedOn = mode == Mode.ON && (activatedByDefault || hasDefinedSetting);\n\n    return passedOn"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "6bd5070e1648fc8069a380902a3246ed282f62bb65a8e8f03dd9ab2c178b0b0e"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Condition 'passedAllMode' is always 'false'",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/diagnostics/infrastructure/DiagnosticsConfiguration.java",
      "language": "JAVA",
      "line": 183,
      "offset": 10,
      "length": 13,
      "code": {
        "startLine": 181,
        "length": 13,
        "offset": 30,
        "surroundingCode": "\n    return passedOn\n      || passedAllMode\n      || passedOnlyMode\n      || passedExcept"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "6d71946a86ec1e81f1f45223d90352a5fd68f6028d1fce1bd8853a5692b9e54f"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "Moderate",
  "comment": "Value 'configuredSkipSupport' is always 'null'",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/diagnostics/infrastructure/DiagnosticsConfiguration.java",
      "language": "JAVA",
      "line": 137,
      "offset": 9,
      "length": 21,
      "code": {
        "startLine": 135,
        "length": 21,
        "offset": 78,
        "surroundingCode": "    var configuredSkipSupport = diagnosticsOptions.getSkipSupport();\n\n    if (configuredSkipSupport == SkipSupport.NEVER) {\n      return true;\n    }"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "6d93d7c7b7e811b316639aacb9fc5c15682d913d3569f9fb0213a5d13fc6016f"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Condition 'operator == BslOperator.AND' is always 'false' when reached",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/diagnostics/IdenticalExpressionsDiagnostic.java",
      "language": "JAVA",
      "line": 263,
      "offset": 40,
      "length": 27,
      "code": {
        "startLine": 261,
        "length": 27,
        "offset": 151,
        "surroundingCode": "  private static boolean isComplementary(BinaryOperationNode binary) {\n    var operator = binary.getOperator();\n    if ((operator == BslOperator.OR || operator == BslOperator.AND)\n      && binary.getRight() instanceof BinaryOperationNode) {\n      return ((BinaryOperationNode) binary.getRight()).getOperator() == operator;"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "6e190c68b178725090721c79977566532ab2db80368a281cb920d7f02e3a08ae"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "Moderate",
  "comment": "Value 'range' is always 'null'",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/diagnostics/WrongDataPathForFormElementsDiagnostic.java",
      "language": "JAVA",
      "line": 63,
      "offset": 25,
      "length": 5,
      "code": {
        "startLine": 61,
        "length": 5,
        "offset": 106,
        "surroundingCode": "\n    var range = documentContext.getSymbolTree().getModule().getSelectionRange();\n    if (!Ranges.isEmpty(range)) {\n      checkCurrentModule(range);\n    }"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "6f35540880ec5b64a0d9f6a063baac8c5e19735dee0494176a3f18881cb8ed58"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "Moderate",
  "comment": "Value 'methodName' is always 'null'",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/codelenses/AbstractMethodComplexityCodeLensSupplier.java",
      "language": "JAVA",
      "line": 72,
      "offset": 53,
      "length": 10,
      "code": {
        "startLine": 70,
        "length": 10,
        "offset": 162,
        "surroundingCode": "    var methodName = data.getMethodName();\n    var methodsComplexity = getMethodsComplexity(documentContext);\n    documentContext.getSymbolTree().getMethodSymbol(methodName).ifPresent((MethodSymbol methodSymbol) -> {\n      int complexity = methodsComplexity.get(methodSymbol);\n"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "7278b765ac965556eedf605ac714b5b7773108f97d8acfb1c0a5bfc83df75de4"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "Moderate",
  "comment": "Value 'fileType' is always 'null'",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/codeactions/GenerateStandardRegionsSupplier.java",
      "language": "JAVA",
      "line": 77,
      "offset": 73,
      "length": 8,
      "code": {
        "startLine": 75,
        "length": 8,
        "offset": 123,
        "surroundingCode": "    var fileType = documentContext.getFileType();\n\n    ScriptVariant regionsLanguage = getRegionsLanguage(documentContext, fileType);\n    Set<String> neededStandardRegions;\n"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "73fb03a7896d8817609e024e82daa49bc586ac846d9749758f833c9201b236a4"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Condition 'Ranges.isEmpty(range)' is always 'false'",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/diagnostics/SetPermissionsForNewObjectsDiagnostic.java",
      "language": "JAVA",
      "line": 66,
      "offset": 9,
      "length": 21,
      "code": {
        "startLine": 64,
        "length": 21,
        "offset": 113,
        "surroundingCode": "  public void check() {\n    var range = documentContext.getSymbolTree().getModule().getSelectionRange();\n    if (Ranges.isEmpty(range)) {\n      return;\n    }"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "74c73dcc7c04ce3650d7bc3b69c83f54a02de6956090dda9c29222ba930b801f"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Condition '!Ranges.isEmpty(range)' is always 'true'",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/diagnostics/WrongDataPathForFormElementsDiagnostic.java",
      "language": "JAVA",
      "line": 63,
      "offset": 9,
      "length": 22,
      "code": {
        "startLine": 61,
        "length": 22,
        "offset": 90,
        "surroundingCode": "\n    var range = documentContext.getSymbolTree().getModule().getSelectionRange();\n    if (!Ranges.isEmpty(range)) {\n      checkCurrentModule(range);\n    }"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "754f4a57db3b47693908fbed971247eb5cd3fe7bcdda1cee94a4c7aafbc58110"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "Moderate",
  "comment": "Value 'language' is always 'null'",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/color/WebColorPresentationSupplier.java",
      "language": "JAVA",
      "line": 73,
      "offset": 45,
      "length": 8,
      "code": {
        "startLine": 71,
        "length": 8,
        "offset": 110,
        "surroundingCode": "    var scriptLocale = documentContext.getScriptVariantLocale();\n\n    var label = Resources.getResourceString(language, getClass(), VIA_WEB_COLOR_KEY);\n    var newText = Resources.getResourceString(\n      scriptLocale,"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "75b7f682c23709754398c5626a0b23d19a557d748614f3d4b54a7a389abacdce"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "Moderate",
  "comment": "Value 'symbol' is always 'null'",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/context/computer/VariableSymbolComputer.java",
      "language": "JAVA",
      "line": 96,
      "offset": 19,
      "length": 6,
      "code": {
        "startLine": 94,
        "length": 6,
        "offset": 55,
        "surroundingCode": "      .scope(module)\n      .build();\n    variables.add(symbol);\n    moduleVariables.put(ctx.var_name().getText(), ctx.var_name().getText());\n    return ctx;"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "7628ef75c018060d91e9e232e1f4b9a966a51fec1aa876655751ae5c87ecf920"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "Moderate",
  "comment": "Value 'variable' is always 'null'",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/context/computer/VariableSymbolComputer.java",
      "language": "JAVA",
      "line": 263,
      "offset": 19,
      "length": 8,
      "code": {
        "startLine": 261,
        "length": 8,
        "offset": 66,
        "surroundingCode": "      .description(description)\n      .build();\n    variables.add(variable);\n\n    // Если файл с ошибками разбора может возникнуть ситуация, когда по дереву мы будем находиться внутри метода,"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "77478d92b912b7a7063c8f1b2b9f265b4b3b0bfa44b03641a80ef6600352020c"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "Moderate",
  "comment": "Value 'symbolDto' is always 'null'",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/references/ReferenceIndex.java",
      "language": "JAVA",
      "line": 90,
      "offset": 54,
      "length": 9,
      "code": {
        "startLine": 88,
        "length": 9,
        "offset": 70,
        "surroundingCode": "      .build();\n\n    return symbolOccurrenceRepository.getAllBySymbol(symbolDto)\n      .stream()\n      .map(this::buildReference)"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "806f522654b26ae63fb0ebe91605de0ee8d7b50a0c0a27fb2417d9079f3d6506"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "Moderate",
  "comment": "Value 'pairedOperand' is always 'null'",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/diagnostics/IdenticalExpressionsDiagnostic.java",
      "language": "JAVA",
      "line": 182,
      "offset": 16,
      "length": 13,
      "code": {
        "startLine": 180,
        "length": 13,
        "offset": 60,
        "surroundingCode": "    List<Token> tokens = new ArrayList<>();\n\n    fillTokens(pairedOperand, tokens);\n\n    // todo: очень плохое место для этого метода"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "8103e89e07ce24c124435e25f481ed623825e2546d716e5be4abf530df4f0ddd"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Condition 'processId == null' is always 'true'",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/ParentProcessWatcher.java",
      "language": "JAVA",
      "line": 53,
      "offset": 9,
      "length": 17,
      "code": {
        "startLine": 51,
        "length": 17,
        "offset": 142,
        "surroundingCode": "  public void handleEvent(LanguageServerInitializeRequestReceivedEvent event) {\n    var processId = event.getParams().getProcessId();\n    if (processId == null) {\n      return;\n    }"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "86a1eda5b512dd47c0a4200200018a1dfb28b955a4308f253c56bba3f2a3139c"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "Moderate",
  "comment": "Value 'range' is always 'null'",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/diagnostics/WrongDataPathForFormElementsDiagnostic.java",
      "language": "JAVA",
      "line": 64,
      "offset": 26,
      "length": 5,
      "code": {
        "startLine": 62,
        "length": 5,
        "offset": 140,
        "surroundingCode": "    var range = documentContext.getSymbolTree().getModule().getSelectionRange();\n    if (!Ranges.isEmpty(range)) {\n      checkCurrentModule(range);\n    }\n  }"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "871a5079dbed3dffdc8ad839e32301d090532f2c87b089138d0949b1e2f5283e"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "Moderate",
  "comment": "Value 'range' is always 'null'",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/diagnostics/AbstractCommonModuleNameDiagnostic.java",
      "language": "JAVA",
      "line": 58,
      "offset": 66,
      "length": 5,
      "code": {
        "startLine": 56,
        "length": 5,
        "offset": 126,
        "surroundingCode": "      .map(pattern::matcher)\n      .filter(this::matchCheck)\n      .ifPresent(commonModule -> diagnosticStorage.addDiagnostic(range));\n  }\n"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "8b4ff8bad39f254290327ad9769d23315d4f797659d309836f971bb93fc99314"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Condition 'currentErrorsMode == SendErrorsMode.SEND || currentErrorsMode == SendErrorsMode.SEND_ONCE' is always 'false'",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/aop/sentry/PermissionFilterBeforeSendCallback.java",
      "language": "JAVA",
      "line": 106,
      "offset": 18,
      "length": 89,
      "code": {
        "startLine": 104,
        "length": 89,
        "offset": 77,
        "surroundingCode": "\n    var currentErrorsMode = configuration.getSendErrors();\n    var result = currentErrorsMode == SendErrorsMode.SEND || currentErrorsMode == SendErrorsMode.SEND_ONCE;\n    if (currentErrorsMode == SendErrorsMode.SEND_ONCE) {\n      configuration.setSendErrors(SendErrorsMode.ASK);"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "8bee2c0fd12169e61e26e1d4b23261f563131274f70bf8873cde8530faedf866"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "Moderate",
  "comment": "Value 'searchableLeft' is always 'null'",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/diagnostics/IdenticalExpressionsDiagnostic.java",
      "language": "JAVA",
      "line": 135,
      "offset": 39,
      "length": 14,
      "code": {
        "startLine": 133,
        "length": 14,
        "offset": 129,
        "surroundingCode": "      BinaryOperationNode complementaryNode = node.getRight().cast();\n      while (true) {\n        var equal = comparer.areEqual(searchableLeft, complementaryNode.getLeft()) ||\n          comparer.areEqual(searchableLeft, complementaryNode.getRight());\n"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "8c82b0d38676c3c12a8ced34787c128a9c75e011b2485eb34910fdb61268e2ec"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Condition '!Ranges.isEmpty(range)' is always 'true'",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/diagnostics/OrdinaryAppSupportDiagnostic.java",
      "language": "JAVA",
      "line": 61,
      "offset": 9,
      "length": 22,
      "code": {
        "startLine": 59,
        "length": 22,
        "offset": 90,
        "surroundingCode": "\n    var range = documentContext.getSymbolTree().getModule().getSelectionRange();\n    if (!Ranges.isEmpty(range)) {\n      checkProperties(range);\n    }"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "8cac5ed698cd83ddc12819704bc46c2b1a366603ef419a224361a3abaf1b63f7"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "Moderate",
  "comment": "Value 'mode' is always 'null'",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/diagnostics/infrastructure/DiagnosticsConfiguration.java",
      "language": "JAVA",
      "line": 178,
      "offset": 30,
      "length": 4,
      "code": {
        "startLine": 176,
        "length": 4,
        "offset": 76,
        "surroundingCode": "\n    boolean passedAllMode = mode == Mode.ALL;\n    boolean passedOnlyMode = mode == Mode.ONLY && hasDefinedSetting;\n    boolean passedExcept = mode == Mode.EXCEPT && !(hasDefinedSetting || disabledDirectly);\n    boolean passedOn = mode == Mode.ON && (activatedByDefault || hasDefinedSetting);"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "8eaf52e9dd1dcece1ca1bef2384edaf0df3c2c786bfb7072fb0450f6eaa675c1"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "Moderate",
  "comment": "Value 'isContextMethod' is always 'null'",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/diagnostics/FormDataToValueDiagnostic.java",
      "language": "JAVA",
      "line": 72,
      "offset": 9,
      "length": 15,
      "code": {
        "startLine": 70,
        "length": 15,
        "offset": 112,
        "surroundingCode": "        || compilerDirective == CompilerDirectiveKind.AT_CLIENT_AT_SERVER_NO_CONTEXT)\n      .isEmpty();\n    if (isContextMethod) {\n      return MESSAGE_PATTERN.matcher(ctx.methodName().getText()).matches();\n    }"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "8f61b62f33f72d2f6fdae43a8fc1ab60b52c0e1aea11571c635d22fa4bd63f5b"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "Moderate",
  "comment": "Value 'symbolOccurrence' is always 'null'",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/references/ReferenceIndex.java",
      "language": "JAVA",
      "line": 191,
      "offset": 37,
      "length": 16,
      "code": {
        "startLine": 189,
        "length": 16,
        "offset": 53,
        "surroundingCode": "      .build();\n\n    symbolOccurrenceRepository.save(symbolOccurrence);\n    locationRepository.updateLocation(symbolOccurrence);\n  }"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "8f847c60053eb9d33de442ae5e8b1c276e5b7eb326af329c225b1c8df435e5ca"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "Moderate",
  "comment": "Value 'executable' is always 'null'",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/codelenses/RunTestCodeLensSupplier.java",
      "language": "JAVA",
      "line": 106,
      "offset": 22,
      "length": 10,
      "code": {
        "startLine": 104,
        "length": 10,
        "offset": 163,
        "surroundingCode": "    var options = configuration.getCodeLensOptions().getTestRunnerAdapterOptions();\n    var executable = options.getExecutableForCurrentOS();\n    String runText = executable + \" \" + options.getRunTestArguments();\n    runText = String.format(runText, path, testId);\n"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "90866d2a89241fcefe2ae721e2ca247e4377bfad669d33d7965a4a792931bb97"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "Moderate",
  "comment": "Value 'operator' is always 'null'",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/diagnostics/IdenticalExpressionsDiagnostic.java",
      "language": "JAVA",
      "line": 243,
      "offset": 13,
      "length": 8,
      "code": {
        "startLine": 241,
        "length": 8,
        "offset": 137,
        "surroundingCode": "        // разыменования отбросим, хотя comparer их и не зачтет, но для производительности\n        // лучше выкинем их сразу\n        if (operator == BslOperator.DEREFERENCE || operator == BslOperator.INDEX_ACCESS) {\n          return;\n        }"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "90aaed127533d20a10e52339cc8fc5d0d74c07e3c790e66c178ac096d9d2345d"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "Moderate",
  "comment": "Value 'fileType' is always 'null'",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/codeactions/GenerateStandardRegionsSupplier.java",
      "language": "JAVA",
      "line": 80,
      "offset": 9,
      "length": 8,
      "code": {
        "startLine": 78,
        "length": 8,
        "offset": 48,
        "surroundingCode": "    Set<String> neededStandardRegions;\n\n    if (fileType == FileType.BSL) {\n      neededStandardRegions = Regions.getStandardRegionsNamesByModuleType(moduleType, regionsLanguage);\n    } else {"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "913da8eb8d24033ad57fcffc3b1d30a00c1cc4bfe10c10a5ba11206a442a1f77"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Condition 'Ranges.isEmpty(range)' is always 'false'",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/diagnostics/AbstractCommonModuleNameDiagnostic.java",
      "language": "JAVA",
      "line": 47,
      "offset": 9,
      "length": 21,
      "code": {
        "startLine": 45,
        "length": 21,
        "offset": 116,
        "surroundingCode": "  protected void check() {\n    var range = documentContext.getSymbolTree().getModule().getSelectionRange();\n    if (Ranges.isEmpty(range)) {\n      return;\n    }"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "93e351f7889e3b39bb7efd2ddda43b04cfabf07334b72dbd1de9d17eeabcb94d"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Condition 'passedExcept' is always 'false'",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/diagnostics/infrastructure/DiagnosticsConfiguration.java",
      "language": "JAVA",
      "line": 185,
      "offset": 10,
      "length": 12,
      "code": {
        "startLine": 183,
        "length": 12,
        "offset": 56,
        "surroundingCode": "      || passedAllMode\n      || passedOnlyMode\n      || passedExcept\n      ;\n"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "96291f8d9babe69ecc37136fc7b8a4e7e3073a8dff9cc95cc88b3196edb4e680"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "Moderate",
  "comment": "Value 'symbolOccurrence' is always 'null'",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/references/ReferenceIndex.java",
      "language": "JAVA",
      "line": 233,
      "offset": 37,
      "length": 16,
      "code": {
        "startLine": 231,
        "length": 16,
        "offset": 53,
        "surroundingCode": "      .build();\n\n    symbolOccurrenceRepository.save(symbolOccurrence);\n    locationRepository.updateLocation(symbolOccurrence);\n  }"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "96c47f25f8206437c8f3985d4d1c2e90b6a316102820374cfb7bb7983d9d867d"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "Moderate",
  "comment": "Value 'testId' is always 'null'",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/codelenses/RunTestCodeLensSupplier.java",
      "language": "JAVA",
      "line": 107,
      "offset": 44,
      "length": 6,
      "code": {
        "startLine": 105,
        "length": 6,
        "offset": 172,
        "surroundingCode": "    var executable = options.getExecutableForCurrentOS();\n    String runText = executable + \" \" + options.getRunTestArguments();\n    runText = String.format(runText, path, testId);\n\n    var command = new Command();"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "97c345c7037a982e705509da9f29604a311633f05e0c26aab7a462a514bdbeca"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "Moderate",
  "comment": "Value 'range' is always 'null'",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/diagnostics/OrdinaryAppSupportDiagnostic.java",
      "language": "JAVA",
      "line": 62,
      "offset": 23,
      "length": 5,
      "code": {
        "startLine": 60,
        "length": 5,
        "offset": 137,
        "surroundingCode": "    var range = documentContext.getSymbolTree().getModule().getSelectionRange();\n    if (!Ranges.isEmpty(range)) {\n      checkProperties(range);\n    }\n  }"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "99153c3b039552337c92c01173e95df31a948fde9ab8b55e6c77a901c081410c"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Condition 'mode == Mode.EXCEPT && !(hasDefinedSetting || disabledDirectly)' is always 'false'",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/diagnostics/infrastructure/DiagnosticsConfiguration.java",
      "language": "JAVA",
      "line": 179,
      "offset": 28,
      "length": 63,
      "code": {
        "startLine": 177,
        "length": 63,
        "offset": 142,
        "surroundingCode": "    boolean passedAllMode = mode == Mode.ALL;\n    boolean passedOnlyMode = mode == Mode.ONLY && hasDefinedSetting;\n    boolean passedExcept = mode == Mode.EXCEPT && !(hasDefinedSetting || disabledDirectly);\n    boolean passedOn = mode == Mode.ON && (activatedByDefault || hasDefinedSetting);\n"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "997673b4753e12fa81660d3838f588dc213cbaee57060fa3d2e3a4f9601b8b3e"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Condition 'mode == Mode.ALL' is always 'false'",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/diagnostics/infrastructure/DiagnosticsConfiguration.java",
      "language": "JAVA",
      "line": 177,
      "offset": 29,
      "length": 16,
      "code": {
        "startLine": 175,
        "length": 16,
        "offset": 104,
        "surroundingCode": "    boolean hasDefinedSetting = enabledDirectly || hasCustomConfiguration;\n\n    boolean passedAllMode = mode == Mode.ALL;\n    boolean passedOnlyMode = mode == Mode.ONLY && hasDefinedSetting;\n    boolean passedExcept = mode == Mode.EXCEPT && !(hasDefinedSetting || disabledDirectly);"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "9b1f51d9921dea5cda49752f76d4a7d03f0c77feb8c7f239765a8238ad8ebd37"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "Moderate",
  "comment": "Value 'range' is always 'null'",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/references/ReferenceIndex.java",
      "language": "JAVA",
      "line": 248,
      "offset": 49,
      "length": 5,
      "code": {
        "startLine": 246,
        "length": 5,
        "offset": 161,
        "surroundingCode": "      .map((SourceDefinedSymbol symbol) -> {\n        SourceDefinedSymbol from = getFromSymbol(symbolOccurrence);\n        return new Reference(from, symbol, uri, range, occurrenceType);\n      })\n      .filter(ReferenceIndex::isReferenceAccessible);"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "9bedafdcf54e51f3150d3c55f7b0e929aa591a0e376f0c25843acd226631c2ef"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "Moderate",
  "comment": "Value 'variable' is always 'null'",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/context/computer/VariableSymbolComputer.java",
      "language": "JAVA",
      "line": 148,
      "offset": 19,
      "length": 8,
      "code": {
        "startLine": 146,
        "length": 8,
        "offset": 71,
        "surroundingCode": "      .description(Optional.empty())\n      .build();\n    variables.add(variable);\n\n    if (currentMethod.getSymbolKind() == SymbolKind.Module) {"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "9cee9d97ecc1ce007015a15609c41ab376eb9d3403300e845a1c1dd679cedc90"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "Moderate",
  "comment": "Value 'useUppercaseForLogicalOrNotAndKeywords' is always 'null'",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/providers/FormatProvider.java",
      "language": "JAVA",
      "line": 580,
      "offset": 9,
      "length": 38,
      "code": {
        "startLine": 578,
        "length": 38,
        "offset": 47,
        "surroundingCode": "    String orKeywordCanonTextEng;\n    \n    if (useUppercaseForLogicalOrNotAndKeywords) {\n      orKeywordCanonTextRu = Keywords.OR_UP_RU;\n      orKeywordCanonTextEng = Keywords.OR_UP_EN;"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "9d5d7486d3167ad024cbdf711962aea892fcc7d1b94493b2268d0890d42584d1"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "Moderate",
  "comment": "Value 'mode' is always 'null'",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/diagnostics/infrastructure/DiagnosticsConfiguration.java",
      "language": "JAVA",
      "line": 177,
      "offset": 29,
      "length": 4,
      "code": {
        "startLine": 175,
        "length": 4,
        "offset": 104,
        "surroundingCode": "    boolean hasDefinedSetting = enabledDirectly || hasCustomConfiguration;\n\n    boolean passedAllMode = mode == Mode.ALL;\n    boolean passedOnlyMode = mode == Mode.ONLY && hasDefinedSetting;\n    boolean passedExcept = mode == Mode.EXCEPT && !(hasDefinedSetting || disabledDirectly);"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "a07d17967f24765e3b978e62fcf67ff0f0f056cab436b325d6df688a8d374c6e"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "Moderate",
  "comment": "Value 'siteRoot' is always 'null'",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/diagnostics/metadata/DiagnosticInfo.java",
      "language": "JAVA",
      "line": 92,
      "offset": 7,
      "length": 8,
      "code": {
        "startLine": 90,
        "length": 8,
        "offset": 79,
        "surroundingCode": "    var siteDiagnosticsUrl = String.format(\n      \"%s%s%s/diagnostics/\",\n      siteRoot,\n      devSuffix,\n      languageSuffix"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "a33a29e6562631bf0f9f023184209b7124ccb9d448899895139b9e53759503b5"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "Moderate",
  "comment": "Value 'currentErrorsMode' is always 'null'",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/aop/sentry/PermissionFilterBeforeSendCallback.java",
      "language": "JAVA",
      "line": 107,
      "offset": 9,
      "length": 17,
      "code": {
        "startLine": 105,
        "length": 17,
        "offset": 175,
        "surroundingCode": "    var currentErrorsMode = configuration.getSendErrors();\n    var result = currentErrorsMode == SendErrorsMode.SEND || currentErrorsMode == SendErrorsMode.SEND_ONCE;\n    if (currentErrorsMode == SendErrorsMode.SEND_ONCE) {\n      configuration.setSendErrors(SendErrorsMode.ASK);\n    }"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "a43d1c516c79389f6fce8dbffcfbc1eeeabaec8ca16e953db0e074c41056408d"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "Moderate",
  "comment": "Value 'executable' is always 'null'",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/codelenses/RunAllTestsCodeLensSupplier.java",
      "language": "JAVA",
      "line": 82,
      "offset": 22,
      "length": 10,
      "code": {
        "startLine": 80,
        "length": 10,
        "offset": 163,
        "surroundingCode": "    var options = configuration.getCodeLensOptions().getTestRunnerAdapterOptions();\n    var executable = options.getExecutableForCurrentOS();\n    String runText = executable + \" \" + options.getRunAllTestsArguments();\n    runText = String.format(runText, path);\n"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "a878280b2859742d5cb08038ed67936478fb458773f7156216cf8cfaa52cf13e"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Condition 'fileType == FileType.BSL' is always 'false'",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/codeactions/GenerateStandardRegionsSupplier.java",
      "language": "JAVA",
      "line": 80,
      "offset": 9,
      "length": 24,
      "code": {
        "startLine": 78,
        "length": 24,
        "offset": 48,
        "surroundingCode": "    Set<String> neededStandardRegions;\n\n    if (fileType == FileType.BSL) {\n      neededStandardRegions = Regions.getStandardRegionsNamesByModuleType(moduleType, regionsLanguage);\n    } else {"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "ab7cf1f07d6c92df3ba4325d94117c10293037a1038abd0adfe1e360ae9f8497"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Condition 'operator == BslOperator.DEREFERENCE || operator == BslOperator.INDEX_ACCESS' is always 'false'",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/diagnostics/IdenticalExpressionsDiagnostic.java",
      "language": "JAVA",
      "line": 243,
      "offset": 13,
      "length": 75,
      "code": {
        "startLine": 241,
        "length": 75,
        "offset": 137,
        "surroundingCode": "        // разыменования отбросим, хотя comparer их и не зачтет, но для производительности\n        // лучше выкинем их сразу\n        if (operator == BslOperator.DEREFERENCE || operator == BslOperator.INDEX_ACCESS) {\n          return;\n        }"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "abd0a328a1be1bfd71e3e84ac454cfcf2ca25fd513bb4124d5c635826a7bc3d9"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "Moderate",
  "comment": "Value 'uri' is always 'null'",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/references/ReferenceIndex.java",
      "language": "JAVA",
      "line": 248,
      "offset": 44,
      "length": 3,
      "code": {
        "startLine": 246,
        "length": 3,
        "offset": 156,
        "surroundingCode": "      .map((SourceDefinedSymbol symbol) -> {\n        SourceDefinedSymbol from = getFromSymbol(symbolOccurrence);\n        return new Reference(from, symbol, uri, range, occurrenceType);\n      })\n      .filter(ReferenceIndex::isReferenceAccessible);"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "b3e5c82abd17d81be09397a9ac19da1b605e0cab524cc35e568e4d618f2c2944"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "Moderate",
  "comment": "Value 'operator' is always 'null'",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/diagnostics/IdenticalExpressionsDiagnostic.java",
      "language": "JAVA",
      "line": 263,
      "offset": 40,
      "length": 8,
      "code": {
        "startLine": 261,
        "length": 8,
        "offset": 151,
        "surroundingCode": "  private static boolean isComplementary(BinaryOperationNode binary) {\n    var operator = binary.getOperator();\n    if ((operator == BslOperator.OR || operator == BslOperator.AND)\n      && binary.getRight() instanceof BinaryOperationNode) {\n      return ((BinaryOperationNode) binary.getRight()).getOperator() == operator;"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "b44457212906dfcb5ee4c175100361f43a90af4f5583196f1c62b7886c8fc3a8"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "Moderate",
  "comment": "Value 'mode' is always 'null'",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/diagnostics/infrastructure/DiagnosticsConfiguration.java",
      "language": "JAVA",
      "line": 160,
      "offset": 9,
      "length": 4,
      "code": {
        "startLine": 158,
        "length": 4,
        "offset": 54,
        "surroundingCode": "\n    var mode = diagnosticsOptions.getMode();\n    if (mode == Mode.OFF) {\n      return false;\n    }"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "bab34821e9e7ba15ff1e81c5370c7de12ad291db4d0a587fbc399e32b856e1dc"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Condition 'passedOn' is always 'false'",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/diagnostics/infrastructure/DiagnosticsConfiguration.java",
      "language": "JAVA",
      "line": 182,
      "offset": 12,
      "length": 8,
      "code": {
        "startLine": 180,
        "length": 8,
        "offset": 97,
        "surroundingCode": "    boolean passedOn = mode == Mode.ON && (activatedByDefault || hasDefinedSetting);\n\n    return passedOn\n      || passedAllMode\n      || passedOnlyMode"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "be2dbff1e32ce8d65f53ecae874252c273a3772594f259693c6066bcab8bfe8e"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "Moderate",
  "comment": "Value 'symbol' is always 'null'",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/context/computer/VariableSymbolComputer.java",
      "language": "JAVA",
      "line": 122,
      "offset": 19,
      "length": 6,
      "code": {
        "startLine": 120,
        "length": 6,
        "offset": 70,
        "surroundingCode": "      .scope(getVariableScope(ctx))\n      .build();\n    variables.add(symbol);\n    currentMethodVariables.put(ctx.var_name().getText(), ctx.var_name().getText());\n    return ctx;"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "c47d664b078a16093c28b7cf6ccd93f8cc4680b620b4791fc5d8bf87eb8282af"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "Moderate",
  "comment": "Value 'currentErrorsMode' is always 'null'",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/aop/sentry/PermissionFilterBeforeSendCallback.java",
      "language": "JAVA",
      "line": 106,
      "offset": 62,
      "length": 17,
      "code": {
        "startLine": 104,
        "length": 17,
        "offset": 121,
        "surroundingCode": "\n    var currentErrorsMode = configuration.getSendErrors();\n    var result = currentErrorsMode == SendErrorsMode.SEND || currentErrorsMode == SendErrorsMode.SEND_ONCE;\n    if (currentErrorsMode == SendErrorsMode.SEND_ONCE) {\n      configuration.setSendErrors(SendErrorsMode.ASK);"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "c5884becee811c61da47bb456980d2b5d81273bd1c1c0512918362530458b26e"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Condition 'passedOn || passedAllMode || passedOnlyMode || passedExcept' is always 'false'",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/diagnostics/infrastructure/DiagnosticsConfiguration.java",
      "language": "JAVA",
      "line": 182,
      "offset": 12,
      "length": 77,
      "code": {
        "startLine": 180,
        "length": 77,
        "offset": 97,
        "surroundingCode": "    boolean passedOn = mode == Mode.ON && (activatedByDefault || hasDefinedSetting);\n\n    return passedOn\n      || passedAllMode\n      || passedOnlyMode\n      || passedExcept\n      ;\n"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "c97fcbd680a34640176eefb04767c74f03273677e268c215b0db437d99fca7e4"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Condition 'currentErrorsMode == SendErrorsMode.SEND' is always 'false'",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/aop/sentry/PermissionFilterBeforeSendCallback.java",
      "language": "JAVA",
      "line": 106,
      "offset": 18,
      "length": 40,
      "code": {
        "startLine": 104,
        "length": 40,
        "offset": 77,
        "surroundingCode": "\n    var currentErrorsMode = configuration.getSendErrors();\n    var result = currentErrorsMode == SendErrorsMode.SEND || currentErrorsMode == SendErrorsMode.SEND_ONCE;\n    if (currentErrorsMode == SendErrorsMode.SEND_ONCE) {\n      configuration.setSendErrors(SendErrorsMode.ASK);"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "ca1308347f4a3944f377c7d5d86cad7c50c6781eddcb83235a1b8c9f3c9bc6ce"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "Moderate",
  "comment": "Value 'range' is always 'null'",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/providers/HoverProvider.java",
      "language": "JAVA",
      "line": 56,
      "offset": 46,
      "length": 5,
      "code": {
        "startLine": 54,
        "length": 5,
        "offset": 211,
        "surroundingCode": "        return Optional.ofNullable(markupContentBuilders.get(symbol.getSymbolKind()))\n          .map(markupContentBuilder -> markupContentBuilder.getContent(symbol))\n          .map(content -> new Hover(content, range));\n      });\n  }"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "ca1e1c924db31c967e4c5e9baad4a696838de4f26dc24b66d569639cd446dee3"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "Moderate",
  "comment": "Value 'operator' is always 'null'",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/diagnostics/IdenticalExpressionsDiagnostic.java",
      "language": "JAVA",
      "line": 263,
      "offset": 10,
      "length": 8,
      "code": {
        "startLine": 261,
        "length": 8,
        "offset": 121,
        "surroundingCode": "  private static boolean isComplementary(BinaryOperationNode binary) {\n    var operator = binary.getOperator();\n    if ((operator == BslOperator.OR || operator == BslOperator.AND)\n      && binary.getRight() instanceof BinaryOperationNode) {\n      return ((BinaryOperationNode) binary.getRight()).getOperator() == operator;"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "ced6347787350c31d0f89031a820feaed7c2fcae2514359900a93653086c2fd4"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Condition '(operator == BslOperator.OR || operator == BslOperator.AND) && binary.getRight() instanceof Bi...' is always 'false'",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/diagnostics/IdenticalExpressionsDiagnostic.java",
      "language": "JAVA",
      "line": 263,
      "offset": 9,
      "length": 117,
      "code": {
        "startLine": 261,
        "length": 117,
        "offset": 120,
        "surroundingCode": "  private static boolean isComplementary(BinaryOperationNode binary) {\n    var operator = binary.getOperator();\n    if ((operator == BslOperator.OR || operator == BslOperator.AND)\n      && binary.getRight() instanceof BinaryOperationNode) {\n      return ((BinaryOperationNode) binary.getRight()).getOperator() == operator;\n    }"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "d81f111aadae4950642df8867916da3da934c993b756ed9365a782432418c588"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Condition 'operator == BslOperator.DEREFERENCE' is always 'false'",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/diagnostics/IdenticalExpressionsDiagnostic.java",
      "language": "JAVA",
      "line": 243,
      "offset": 13,
      "length": 35,
      "code": {
        "startLine": 241,
        "length": 35,
        "offset": 137,
        "surroundingCode": "        // разыменования отбросим, хотя comparer их и не зачтет, но для производительности\n        // лучше выкинем их сразу\n        if (operator == BslOperator.DEREFERENCE || operator == BslOperator.INDEX_ACCESS) {\n          return;\n        }"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "d88e1bc8bf4424e747cdda0d1cba1f790cc96ae05301ea8ef4d82958169bf44e"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "Moderate",
  "comment": "Value 'result' is always 'false'",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/aop/sentry/PermissionFilterBeforeSendCallback.java",
      "language": "JAVA",
      "line": 111,
      "offset": 12,
      "length": 6,
      "code": {
        "startLine": 109,
        "length": 6,
        "offset": 18,
        "surroundingCode": "    }\n\n    return result;\n  }\n"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "d8e8b49bcd723fabb576620a8c035201aa90230884af78ca923b55cfb0b3d828"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "Moderate",
  "comment": "Value 'position' is always 'null'",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/references/ReferenceIndex.java",
      "language": "JAVA",
      "line": 283,
      "offset": 68,
      "length": 8,
      "code": {
        "startLine": 281,
        "length": 8,
        "offset": 200,
        "surroundingCode": "      .flatMap(Collection::stream)\n      .filter(sourceDefinedSymbol -> sourceDefinedSymbol.getSymbolKind() != SymbolKind.Namespace)\n      .filter(symbol -> Ranges.containsPosition(symbol.getRange(), position))\n      .findFirst()\n      .or(() -> symbolTree.map(SymbolTree::getModule))"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "d8f29ba6d29f4509ff034a5df747f071e97edef0b68526a1285570b0e6b09d8f"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Condition 'currentErrorsMode == SendErrorsMode.SEND_ONCE' is always 'false' when reached",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/aop/sentry/PermissionFilterBeforeSendCallback.java",
      "language": "JAVA",
      "line": 106,
      "offset": 62,
      "length": 45,
      "code": {
        "startLine": 104,
        "length": 45,
        "offset": 121,
        "surroundingCode": "\n    var currentErrorsMode = configuration.getSendErrors();\n    var result = currentErrorsMode == SendErrorsMode.SEND || currentErrorsMode == SendErrorsMode.SEND_ONCE;\n    if (currentErrorsMode == SendErrorsMode.SEND_ONCE) {\n      configuration.setSendErrors(SendErrorsMode.ASK);"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "dcf48e6310aea9c0ad34f60e9859fb7ec27c4653fe01eb10d2048da795f53363"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "Moderate",
  "comment": "Value 'currentErrorsMode' is always 'null'",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/aop/sentry/PermissionFilterBeforeSendCallback.java",
      "language": "JAVA",
      "line": 106,
      "offset": 18,
      "length": 17,
      "code": {
        "startLine": 104,
        "length": 17,
        "offset": 77,
        "surroundingCode": "\n    var currentErrorsMode = configuration.getSendErrors();\n    var result = currentErrorsMode == SendErrorsMode.SEND || currentErrorsMode == SendErrorsMode.SEND_ONCE;\n    if (currentErrorsMode == SendErrorsMode.SEND_ONCE) {\n      configuration.setSendErrors(SendErrorsMode.ASK);"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "dd9fa4c0c3d15554b76ffd7ba9cd8811eebe84521f69d817468f40f6d6755655"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Condition 'range != null' is always 'false'",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/BSLTextDocumentService.java",
      "language": "JAVA",
      "line": 453,
      "offset": 11,
      "length": 13,
      "code": {
        "startLine": 451,
        "length": 13,
        "offset": 48,
        "surroundingCode": "\n      var range = params.getRange();\n      if (range != null) {\n        diagnostics = diagnostics.stream()\n          .filter(diagnostic -> Ranges.containsRange(range, diagnostic.getRange()))"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "dff66b20391b7fe9b90ae569f428934209738eb8231c79dad231bc4840a9ce90"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Condition 'currentErrorsMode == SendErrorsMode.SEND_ONCE' is always 'false'",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/aop/sentry/PermissionFilterBeforeSendCallback.java",
      "language": "JAVA",
      "line": 107,
      "offset": 9,
      "length": 45,
      "code": {
        "startLine": 105,
        "length": 45,
        "offset": 175,
        "surroundingCode": "    var currentErrorsMode = configuration.getSendErrors();\n    var result = currentErrorsMode == SendErrorsMode.SEND || currentErrorsMode == SendErrorsMode.SEND_ONCE;\n    if (currentErrorsMode == SendErrorsMode.SEND_ONCE) {\n      configuration.setSendErrors(SendErrorsMode.ASK);\n    }"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "e3a60c0e78bb0e37c3159fccee78fcb36134037214ef9c0c0c2b5eb4d349aed8"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Condition 'configuredMode == Mode.OFF' is always 'false'",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/diagnostics/infrastructure/DiagnosticsConfiguration.java",
      "language": "JAVA",
      "line": 131,
      "offset": 9,
      "length": 26,
      "code": {
        "startLine": 129,
        "length": 26,
        "offset": 64,
        "surroundingCode": "    var configuredMode = diagnosticsOptions.getMode();\n\n    if (configuredMode == Mode.OFF) {\n      return false;\n    }"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "e4e2a7a5ae6b81fb130af3469e869d0ea9254832145f1167d7424d107120d3c6"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Condition 'mode == Mode.OFF' is always 'false'",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/diagnostics/infrastructure/DiagnosticsConfiguration.java",
      "language": "JAVA",
      "line": 160,
      "offset": 9,
      "length": 16,
      "code": {
        "startLine": 158,
        "length": 16,
        "offset": 54,
        "surroundingCode": "\n    var mode = diagnosticsOptions.getMode();\n    if (mode == Mode.OFF) {\n      return false;\n    }"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "e5ef502af16f9e13cd2621683d472e5a815e78476100808fc5e5be7bce603e66"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "Moderate",
  "comment": "Value 'firstMethod' is always 'null'",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/codelenses/RunAllTestsCodeLensSupplier.java",
      "language": "JAVA",
      "line": 70,
      "offset": 31,
      "length": 11,
      "code": {
        "startLine": 68,
        "length": 11,
        "offset": 85,
        "surroundingCode": "    var firstMethod = symbolTree.getMethods().get(0);\n\n    return List.of(toCodeLens(firstMethod, documentContext));\n  }\n"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "e67f75a13740f4dba3ec88580469b28fa9050680f1704ac35b927e51a9441862"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "Moderate",
  "comment": "Value 'occurrenceType' is always 'null'",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/references/ReferenceIndex.java",
      "language": "JAVA",
      "line": 248,
      "offset": 56,
      "length": 14,
      "code": {
        "startLine": 246,
        "length": 14,
        "offset": 168,
        "surroundingCode": "      .map((SourceDefinedSymbol symbol) -> {\n        SourceDefinedSymbol from = getFromSymbol(symbolOccurrence);\n        return new Reference(from, symbol, uri, range, occurrenceType);\n      })\n      .filter(ReferenceIndex::isReferenceAccessible);"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "eb7e64b98e57bf14cd880603eadf2708ccee14bd5a6193f581d2bc4833106204"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "Moderate",
  "comment": "Value 'callNode' is always 'null'",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/utils/expressiontree/ExpressionTreeBuildingVisitor.java",
      "language": "JAVA",
      "line": 362,
      "offset": 81,
      "length": 8,
      "code": {
        "startLine": 360,
        "length": 8,
        "offset": 241,
        "surroundingCode": "    var callNode = MethodCallNode.create(methodCall.methodName().IDENTIFIER());\n    addCallArguments(callNode, methodCall.doCall().callParamList().callParam());\n    var operation = BinaryOperationNode.create(BslOperator.DEREFERENCE, target, callNode, ctx);\n    operands.push(operation);\n    return ctx;"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "f0ea8019a210ed378dbab1a8d97dc733d7bbae72e3dfb445ef5a25db7c16f225"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "Moderate",
  "comment": "Value 'paramString' is always 'null'",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/diagnostics/MissingParameterDescriptionDiagnostic.java",
      "language": "JAVA",
      "line": 146,
      "offset": 42,
      "length": 11,
      "code": {
        "startLine": 144,
        "length": 11,
        "offset": 214,
        "surroundingCode": "        .map(ParameterDefinition::getName).collect(Collectors.joining(\",\")).toLowerCase(Locale.ENGLISH);\n      // если строки не равны, значит порядок описаний не совпадает\n      if (!paramDescriptionString.equals(paramString)) {\n        diagnosticStorage.addDiagnostic(methodSymbol.getSubNameRange(), info.getResourceString(\"wrongOrder\"));\n      }"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "f147e4b065188c7993707a19a7935de25d5783da3183cb9f67598a002050ea18"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Condition 'mode == Mode.ON && (activatedByDefault || hasDefinedSetting)' is always 'false'",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/diagnostics/infrastructure/DiagnosticsConfiguration.java",
      "language": "JAVA",
      "line": 180,
      "offset": 24,
      "length": 60,
      "code": {
        "startLine": 178,
        "length": 60,
        "offset": 184,
        "surroundingCode": "    boolean passedOnlyMode = mode == Mode.ONLY && hasDefinedSetting;\n    boolean passedExcept = mode == Mode.EXCEPT && !(hasDefinedSetting || disabledDirectly);\n    boolean passedOn = mode == Mode.ON && (activatedByDefault || hasDefinedSetting);\n\n    return passedOn"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "f29f805a77d4c81dc8f51a6d4d272ee5b65199b69dd755a1728597209bdb79bc"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Condition 'language == Language.EN' is always 'false'",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/diagnostics/metadata/DiagnosticInfo.java",
      "language": "JAVA",
      "line": 88,
      "offset": 26,
      "length": 23,
      "code": {
        "startLine": 86,
        "length": 23,
        "offset": 119,
        "surroundingCode": "    var siteRoot = configuration.getSiteRoot();\n    var devSuffix = useDevSite ? \"/dev\" : \"\";\n    var languageSuffix = language == Language.EN ? \"/en\" : \"\";\n\n    var siteDiagnosticsUrl = String.format("
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "f30490e67177f80194c42304d5500f2c7d6e43d1164e7fa409822400053c27ec"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Condition 'operator != BslOperator.ADD && operator != BslOperator.MULTIPLY' is always 'true'",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/diagnostics/IdenticalExpressionsDiagnostic.java",
      "language": "JAVA",
      "line": 248,
      "offset": 13,
      "length": 63,
      "code": {
        "startLine": 246,
        "length": 63,
        "offset": 80,
        "surroundingCode": "\n        // одинаковые умножения и сложения - не считаем, см. тесты\n        if (operator != BslOperator.ADD && operator != BslOperator.MULTIPLY) {\n          list.add(binary);\n        }"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "f35f14c81cfb193068dd5b2f80e442d5f260d526578331b135af77bbca9e9f21"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "Moderate",
  "comment": "Value 'language' is always 'null'",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/diagnostics/metadata/DiagnosticInfo.java",
      "language": "JAVA",
      "line": 88,
      "offset": 26,
      "length": 8,
      "code": {
        "startLine": 86,
        "length": 8,
        "offset": 119,
        "surroundingCode": "    var siteRoot = configuration.getSiteRoot();\n    var devSuffix = useDevSite ? \"/dev\" : \"\";\n    var languageSuffix = language == Language.EN ? \"/en\" : \"\";\n\n    var siteDiagnosticsUrl = String.format("
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "f3d68ead529f5e708c19850f12bfcd8bdebbfa04420f426f39fad06c72913cc5"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Condition 'configuredSkipSupport == SkipSupport.NEVER' is always 'false'",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/diagnostics/infrastructure/DiagnosticsConfiguration.java",
      "language": "JAVA",
      "line": 137,
      "offset": 9,
      "length": 42,
      "code": {
        "startLine": 135,
        "length": 42,
        "offset": 78,
        "surroundingCode": "    var configuredSkipSupport = diagnosticsOptions.getSkipSupport();\n\n    if (configuredSkipSupport == SkipSupport.NEVER) {\n      return true;\n    }"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "f719fbc90f409e6d43107f1df7492b18221cf48c2537765fff84edf166ddda98"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "Moderate",
  "comment": "Value 'language' is always 'null'",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/documentlink/DiagnosticDescriptionDocumentLinkSupplier.java",
      "language": "JAVA",
      "line": 62,
      "offset": 39,
      "length": 8,
      "code": {
        "startLine": 60,
        "length": 8,
        "offset": 107,
        "surroundingCode": "          diagnostic.getCodeDescription().getHref(),\n          null,\n          Resources.getResourceString(language, this.getClass(), \"tooltip\", diagnosticCode)\n        );\n      })"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "f7cd3758a8b568e63b41c6dc1d0be1fe52f3a5131d0f9251aee4073aa0b7bf57"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "Moderate",
  "comment": "Value 'uriCompare' is always 'null'",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/references/model/SymbolOccurrence.java",
      "language": "JAVA",
      "line": 58,
      "offset": 9,
      "length": 10,
      "code": {
        "startLine": 56,
        "length": 10,
        "offset": 91,
        "surroundingCode": "    }\n    final var uriCompare = location.getUri().compareTo(o.location.getUri());\n    if (uriCompare != 0){\n      return uriCompare;\n    }"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "fa88184afda9788d06613efb9d646e5bf3b26f161579e7d3bf7cbb331335502e"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "Moderate",
  "comment": "Value 'language' is always 'null'",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/color/ConstructorColorPresentationSupplier.java",
      "language": "JAVA",
      "line": 62,
      "offset": 45,
      "length": 8,
      "code": {
        "startLine": 60,
        "length": 8,
        "offset": 110,
        "surroundingCode": "    var scriptLocale = documentContext.getScriptVariantLocale();\n\n    var label = Resources.getResourceString(language, getClass(), VIA_CONSTRUCTOR_KEY);\n    var newText = Resources.getResourceString(\n      scriptLocale,"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "fe0caf27eb0052e4fa41beb675b34eaecad2c3ee7b69ccf327da482f2dc8814b"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "Moderate",
  "comment": "Value 'operator' is always 'null'",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/diagnostics/IdenticalExpressionsDiagnostic.java",
      "language": "JAVA",
      "line": 248,
      "offset": 44,
      "length": 8,
      "code": {
        "startLine": 246,
        "length": 8,
        "offset": 111,
        "surroundingCode": "\n        // одинаковые умножения и сложения - не считаем, см. тесты\n        if (operator != BslOperator.ADD && operator != BslOperator.MULTIPLY) {\n          list.add(binary);\n        }"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "fef665c030c55fd33d98f0c3d5948627993fb8b11529dd5108ef78819641e2ee"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Constant values",
  "tags": [
    "JAVA"
  ],
  "severity": "Moderate",
  "comment": "Value 'executable' is always 'null'",
  "detailsInfo": "Reports expressions and conditions that always produce the same result, like true, false, null, or zero. Such expressions could be replaced with the corresponding constant value. Very often though they signal about a bug in the code.\n\nExamples:\n\n      // always true\n      // root cause: || is used instead of &&\n      if (x > 0 || x < 10) {}\n\n      System.out.println(str.trim());\n      // always false\n      // root cause: variable was dereferenced before null-check\n      if (str == null) {}\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Don't report assertions with condition statically proven to be always true** option to avoid reporting assertions that were statically proven to be always true. This also includes conditions like `if (alwaysFalseCondition) throw new IllegalArgumentException();`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Warn when constant is stored in variable** option to display warnings when variable is used, whose value is known to be a constant.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of \"Constant Conditions \\& Exceptions\" inspection. Now, it split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/codelenses/testrunner/TestRunnerAdapter.java",
      "language": "JAVA",
      "line": 83,
      "offset": 43,
      "length": 10,
      "code": {
        "startLine": 81,
        "length": 10,
        "offset": 116,
        "surroundingCode": "    var arguments = String.format(options.getGetTestsArguments(), path);\n\n    var getTestsCommand = new CommandLine(executable).addArguments(arguments, false);\n\n    var timeout = 10_000L;"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "ConstantValue"
  },
  "hash": "ff4f5c3d4b537365c6e00c220ee6f83a78ad4b630474a173092d384d3e979833"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Nullability and data flow problems",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Method invocation 'getRuleIndex' may produce 'NullPointerException'",
  "detailsInfo": "Reports code constructs that always violate nullability contracts, may throw exceptions, or are just redundant, based on data flow analysis.\n\nExamples:\n\n    if (array.length < index) {\n      System.out.println(array[index]);\n    } // Array index is always out of bounds\n\n    if (str == null) System.out.println(\"str is null\");\n    System.out.println(str.trim());\n    // the last statement may throw an NPE\n\n    @NotNull\n    Integer square(@Nullable Integer input) {\n        // the method contract is violated\n        return input == null ? null : input * input;\n    }\n\n\nThe inspection behavior may be controlled by a number of annotations, such as\n[nullability](https://www.jetbrains.com/help/idea/nullable-and-notnull-annotations.html) annotations,\n[@Contract](https://www.jetbrains.com/help/idea/contract-annotations.html) annotation,\n`@Range` annotation and so on.\n\nConfigure the inspection:\n\n* Use the **Suggest @Nullable annotation for methods/fields/parameters where nullable values are used** option to warn when a nullable value is passed as an argument to a method with a non-annotated parameter, stored into non-annotated field, or returned from a non-annotated method. In this case, the inspection will suggest propagating the `@Nullable` annotation. You can also configure nullability annotations using the **Configure Annotations** button.\n* Use the **Treat non-annotated members and parameters as @Nullable** option to assume that non-annotated members can be null, so they must not be used in non-null context.\n* Use the **Report not-null required parameter with null-literal argument usages** option to report method parameters that cannot be null (e.g. immediately dereferenced in the method body), but there are call sites where a `null` literal is passed.\n* Use the **Report nullable methods that always return a non-null value** option to report methods that are annotated as `@Nullable`, but always return non-null value. In this case, it's suggested that you change the annotation to `@NotNull`.\n* Use the **Ignore assert statements** option to control how the inspection treats `assert` statements. By default, the option is disabled, which means that the assertions are assumed to be executed (-ea mode). If the option is enabled, the assertions will be completely ignored (-da mode).\n* Use the **Report problems that happen only on some code paths** option to control whether to report problems that may happen only on some code path. If this option is disabled, warnings like *exception is possible* will not be reported. The inspection will report only warnings like *exception will definitely occur*. This mode may greatly reduce the number of false-positives, especially if the code is not consistently annotated with nullability and contract annotations. That is why it can be useful for finding the most important problems in legacy code bases.\n\n\nBefore IntelliJ IDEA 2022.3, this inspection was part of the \"Constant Conditions \\& Exceptions\" inspection.\nNow, it is split into two inspections:\n\"Constant Values\" and \"Nullability and data flow problems\".",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/diagnostics/RefOveruseDiagnostic.java",
      "language": "JAVA",
      "line": 123,
      "offset": 10,
      "length": 12,
      "code": {
        "startLine": 121,
        "length": 12,
        "offset": 224,
        "surroundingCode": "      .filter(parserRuleContext -> parserRuleContext.getRuleIndex() == SDBLParser.RULE_column)\n      .filter(parserRuleContext -> Trees.getRootParent((BSLParserRuleContext) parserRuleContext, EXCLUDED_COLUMNS_ROOT)\n        .getRuleIndex() == SDBLParser.RULE_query)\n      .map(SDBLParser.ColumnContext.class::cast)\n      .collect(Collectors.toList());"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "DataFlowIssue"
  },
  "hash": "ca36652f98b13d10a9d71d59ef8e81f6de236ead3dbff7870a46477290c3b88a"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Statement with empty body",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "'else' statement has empty body",
  "detailsInfo": "Reports `if`, `while`, `do`, `for`, and `switch` statements with empty bodies.\n\nWhile occasionally intended, such code is confusing and is often the result of a typo.\n\nThis inspection is disabled in JSP files.",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/context/symbol/description/DescriptionReader.java",
      "language": "JAVA",
      "line": 372,
      "offset": 9,
      "length": 4,
      "code": {
        "startLine": 370,
        "length": 4,
        "offset": 137,
        "surroundingCode": "      } else if (paramType.complexType() != null) {\n        addType(paramDescription, paramType.complexType().getText(), false);\n      } else {\n        // noop\n      }"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "EmptyStatementBody"
  },
  "hash": "186a03e6f066f5f87334e545cca0a7086390208fb6070c694b4b32366cd2164f"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Statement with empty body",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "'else' statement has empty body",
  "detailsInfo": "Reports `if`, `while`, `do`, `for`, and `switch` statements with empty bodies.\n\nWhile occasionally intended, such code is confusing and is often the result of a typo.\n\nThis inspection is disabled in JSP files.",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/context/symbol/description/DescriptionReader.java",
      "language": "JAVA",
      "line": 263,
      "offset": 9,
      "length": 4,
      "code": {
        "startLine": 261,
        "length": 4,
        "offset": 156,
        "surroundingCode": "      } else if (string.subParameter() != null) { // это строка с вложенным параметром типа\n        current.addSubParameter(string.subParameter());\n      } else { // прочее - пустая строка\n        // noop\n      }"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "EmptyStatementBody"
  },
  "hash": "1c19b07a218fc8cbfac17a15e814465e6a8c18b9ee15c80a5b6ddc502351f40f"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Statement with empty body",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "'else' statement has empty body",
  "detailsInfo": "Reports `if`, `while`, `do`, `for`, and `switch` statements with empty bodies.\n\nWhile occasionally intended, such code is confusing and is often the result of a typo.\n\nThis inspection is disabled in JSP files.",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/context/symbol/description/DescriptionReader.java",
      "language": "JAVA",
      "line": 124,
      "offset": 9,
      "length": 4,
      "code": {
        "startLine": 122,
        "length": 4,
        "offset": 158,
        "surroundingCode": "      } else if (string.subParameter() != null) { // это строка с вложенным параметром типа\n        fakeParam.addSubParameter(string.subParameter());\n      } else { // прочее - пустая строка\n        // noop\n      }"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "EmptyStatementBody"
  },
  "hash": "472d96730e8cd15325bdedccacc4e62d1beaad9ea8c6ca495ec9419eb738a088"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Statement with empty body",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "'else' statement has empty body",
  "detailsInfo": "Reports `if`, `while`, `do`, `for`, and `switch` statements with empty bodies.\n\nWhile occasionally intended, such code is confusing and is often the result of a typo.\n\nThis inspection is disabled in JSP files.",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/diagnostics/NestedFunctionInParametersDiagnostic.java",
      "language": "JAVA",
      "line": 158,
      "offset": 9,
      "length": 4,
      "code": {
        "startLine": 156,
        "length": 4,
        "offset": 150,
        "surroundingCode": "        needReturn = !allowedMethodNamesPattern.matcher(\n          ((BSLParser.GlobalMethodCallContext) t).methodName().getText()).matches();\n      } else {\n        // no-op\n      }"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "EmptyStatementBody"
  },
  "hash": "5b28c533bffb2dc8625cb1d8217bf0ea4cc15e1d387abfeb74e15f3b0b064b26"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Statement with empty body",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "'else' statement has empty body",
  "detailsInfo": "Reports `if`, `while`, `do`, `for`, and `switch` statements with empty bodies.\n\nWhile occasionally intended, such code is confusing and is often the result of a typo.\n\nThis inspection is disabled in JSP files.",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/providers/FormatProvider.java",
      "language": "JAVA",
      "line": 279,
      "offset": 9,
      "length": 4,
      "code": {
        "startLine": 277,
        "length": 4,
        "offset": 124,
        "surroundingCode": "      } else if (needAddSpace(tokenType, previousTokenType, previousIsUnary)) {\n        newTextBuilder.append(' ');\n      } else {\n        // no-op\n      }"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "EmptyStatementBody"
  },
  "hash": "69cdd380ee9b9e5b52fc87cb73b34e337fde9c37de27f182a66efdb8517fd5bf"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Infinite recursion",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Method 'getChildrenFlat()' recurses infinitely, and can only end by throwing an exception",
  "detailsInfo": "Reports methods that call themselves infinitely unless an exception is thrown.\n\n\nMethods reported by this inspection cannot return normally.\nWhile such behavior may be intended, in many cases this is just an oversight.\n\n**Example:**\n\n      int baz() {\n          return baz();\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/context/symbol/SymbolTree.java",
      "language": "JAVA",
      "line": 95,
      "offset": 22,
      "length": 15,
      "code": {
        "startLine": 93,
        "length": 15,
        "offset": 81,
        "surroundingCode": "   * @return плоский список символов указанного типа.\n   */\n  public <T> List<T> getChildrenFlat(Class<T> clazz) {\n    return getChildrenFlat().stream()\n      .filter(clazz::isInstance)"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "InfiniteRecursion"
  },
  "hash": "da2d0b6f78cd722152901ea5806171a1f300d46e90d280223943bfe0fa36e155"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Infinite recursion",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Method 'builder()' recurses infinitely, and can only end by throwing an exception",
  "detailsInfo": "Reports methods that call themselves infinitely unless an exception is thrown.\n\n\nMethods reported by this inspection cannot return normally.\nWhile such behavior may be intended, in many cases this is just an oversight.\n\n**Example:**\n\n      int baz() {\n          return baz();\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/context/symbol/VariableSymbol.java",
      "language": "JAVA",
      "line": 54,
      "offset": 41,
      "length": 7,
      "code": {
        "startLine": 52,
        "length": 7,
        "offset": 75,
        "surroundingCode": "  SourceDefinedSymbol getScope();\n\n  static AbstractVariableSymbol.Builder builder() {\n    return AbstractVariableSymbol.builder();\n  }"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "InfiniteRecursion"
  },
  "hash": "fd765a2fe5015d3cc479abb2c49bff4ec13f8f4c622d70a8e1c7bf6f605e54c4"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Mismatched read and write of array",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Contents of array 'reportersOptions' are read, but never written to",
  "detailsInfo": "Reports arrays whose contents are read but not updated, or updated but not read. Such inconsistent reads and writes are pointless and probably indicate dead, incomplete or erroneous code.\n\n**Example:**\n\n\n      final int[] bar = new int[3];\n      bar[2] = 3;\n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/cli/AnalyzeCommand.java",
      "language": "JAVA",
      "line": 135,
      "offset": 20,
      "length": 16,
      "code": {
        "startLine": 133,
        "length": 16,
        "offset": 128,
        "surroundingCode": "    completionCandidates = ReportersKeys.class,\n    description = \"Reporter key (${COMPLETION-CANDIDATES})\")\n  private String[] reportersOptions = {};\n\n  @Option("
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "MismatchedArrayReadWrite"
  },
  "hash": "e241e797acffd455e52ad9ea6a7b498cbd4fb1e3c82d3de338883db0a8224afb"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Mismatched query and update of collection",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Contents of collection 'languageClientAwares' are queried, but never updated",
  "detailsInfo": "Reports collections whose contents are either queried and not updated, or updated and not queried.\n\n\nSuch inconsistent queries and updates are pointless and may indicate\neither dead code or a typo.\n\n\nUse the inspection settings to specify name patterns that correspond to update/query methods.\nQuery methods that return an element are automatically detected, and only\nthose that write data to an output parameter (for example, an `OutputStream`) need to be specified.\n\n\n**Example:**\n\nSuppose you have your custom `FixedStack` class with method `store()`:\n\n\n      public class FixedStack<T> extends Collection<T> {\n        public T store(T t) {\n          // implementation\n        }\n      }\n\nYou can add `store` to the update methods table in order to report mismatched queries like:\n\n\n      void test(int i) {\n        FixedStack<Integer> stack = new FixedStack<>();\n        stack.store(i);\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/cli/LanguageServerStartCommand.java",
      "language": "JAVA",
      "line": 73,
      "offset": 43,
      "length": 20,
      "code": {
        "startLine": 71,
        "length": 20,
        "offset": 152,
        "surroundingCode": "  private final LanguageServerConfiguration configuration;\n  private final Launcher<LanguageClient> launcher;\n  private final List<LanguageClientAware> languageClientAwares;\n\n  public Integer call() {"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "MismatchedCollectionQueryUpdate"
  },
  "hash": "2f4103bd64eeb9fde80ff24f7a8f9bc69c57081b0a55c4bfe615a5d10f84b8e5"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Mismatched query and update of collection",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Contents of collection 'markupContentBuilders' are queried, but never updated",
  "detailsInfo": "Reports collections whose contents are either queried and not updated, or updated and not queried.\n\n\nSuch inconsistent queries and updates are pointless and may indicate\neither dead code or a typo.\n\n\nUse the inspection settings to specify name patterns that correspond to update/query methods.\nQuery methods that return an element are automatically detected, and only\nthose that write data to an output parameter (for example, an `OutputStream`) need to be specified.\n\n\n**Example:**\n\nSuppose you have your custom `FixedStack` class with method `store()`:\n\n\n      public class FixedStack<T> extends Collection<T> {\n        public T store(T t) {\n          // implementation\n        }\n      }\n\nYou can add `store` to the update methods table in order to report mismatched queries like:\n\n\n      void test(int i) {\n        FixedStack<Integer> stack = new FixedStack<>();\n        stack.store(i);\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/providers/HoverProvider.java",
      "language": "JAVA",
      "line": 44,
      "offset": 63,
      "length": 21,
      "code": {
        "startLine": 42,
        "length": 21,
        "offset": 116,
        "surroundingCode": "\n  private final ReferenceResolver referenceResolver;\n  private final Map<SymbolKind, MarkupContentBuilder<Symbol>> markupContentBuilders;\n\n  public Optional<Hover> getHover(DocumentContext documentContext, HoverParams params) {"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "MismatchedCollectionQueryUpdate"
  },
  "hash": "32b2a0274bee220a65850ec64471b0cda48f60cc420a90ae5538c0ac8eb74ea8"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Mismatched query and update of collection",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Contents of collection 'colorInformationSuppliers' are queried, but never updated",
  "detailsInfo": "Reports collections whose contents are either queried and not updated, or updated and not queried.\n\n\nSuch inconsistent queries and updates are pointless and may indicate\neither dead code or a typo.\n\n\nUse the inspection settings to specify name patterns that correspond to update/query methods.\nQuery methods that return an element are automatically detected, and only\nthose that write data to an output parameter (for example, an `OutputStream`) need to be specified.\n\n\n**Example:**\n\nSuppose you have your custom `FixedStack` class with method `store()`:\n\n\n      public class FixedStack<T> extends Collection<T> {\n        public T store(T t) {\n          // implementation\n        }\n      }\n\nYou can add `store` to the update methods table in order to report mismatched queries like:\n\n\n      void test(int i) {\n        FixedStack<Integer> stack = new FixedStack<>();\n        stack.store(i);\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/providers/ColorProvider.java",
      "language": "JAVA",
      "line": 47,
      "offset": 48,
      "length": 25,
      "code": {
        "startLine": 45,
        "length": 25,
        "offset": 101,
        "surroundingCode": "@RequiredArgsConstructor\npublic class ColorProvider {\n  private final List<ColorInformationSupplier> colorInformationSuppliers;\n  private final List<ColorPresentationSupplier> colorPresentationSuppliers;\n"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "MismatchedCollectionQueryUpdate"
  },
  "hash": "3cb8d212e57eca6b2037187112a10472cc23eacc443670d92502de320e1a5b16"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Mismatched query and update of collection",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Contents of collection 'reporters' are queried, but never updated",
  "detailsInfo": "Reports collections whose contents are either queried and not updated, or updated and not queried.\n\n\nSuch inconsistent queries and updates are pointless and may indicate\neither dead code or a typo.\n\n\nUse the inspection settings to specify name patterns that correspond to update/query methods.\nQuery methods that return an element are automatically detected, and only\nthose that write data to an output parameter (for example, an `OutputStream`) need to be specified.\n\n\n**Example:**\n\nSuppose you have your custom `FixedStack` class with method `store()`:\n\n\n      public class FixedStack<T> extends Collection<T> {\n        public T store(T t) {\n          // implementation\n        }\n      }\n\nYou can add `store` to the update methods table in order to report mismatched queries like:\n\n\n      void test(int i) {\n        FixedStack<Integer> stack = new FixedStack<>();\n        stack.store(i);\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/reporters/ReportersAggregator.java",
      "language": "JAVA",
      "line": 40,
      "offset": 36,
      "length": 9,
      "code": {
        "startLine": 38,
        "length": 9,
        "offset": 49,
        "surroundingCode": "\n  @Autowired\n  private List<DiagnosticReporter> reporters;\n\n  @Autowired"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "MismatchedCollectionQueryUpdate"
  },
  "hash": "3df83e56f8cd4f26c7e882de81756363030a4d94c53973fba3d38f170da9a252"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Mismatched query and update of collection",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Contents of collection 'colorPresentationSuppliers' are queried, but never updated",
  "detailsInfo": "Reports collections whose contents are either queried and not updated, or updated and not queried.\n\n\nSuch inconsistent queries and updates are pointless and may indicate\neither dead code or a typo.\n\n\nUse the inspection settings to specify name patterns that correspond to update/query methods.\nQuery methods that return an element are automatically detected, and only\nthose that write data to an output parameter (for example, an `OutputStream`) need to be specified.\n\n\n**Example:**\n\nSuppose you have your custom `FixedStack` class with method `store()`:\n\n\n      public class FixedStack<T> extends Collection<T> {\n        public T store(T t) {\n          // implementation\n        }\n      }\n\nYou can add `store` to the update methods table in order to report mismatched queries like:\n\n\n      void test(int i) {\n        FixedStack<Integer> stack = new FixedStack<>();\n        stack.store(i);\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/providers/ColorProvider.java",
      "language": "JAVA",
      "line": 48,
      "offset": 49,
      "length": 26,
      "code": {
        "startLine": 46,
        "length": 26,
        "offset": 151,
        "surroundingCode": "public class ColorProvider {\n  private final List<ColorInformationSupplier> colorInformationSuppliers;\n  private final List<ColorPresentationSupplier> colorPresentationSuppliers;\n\n  /**"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "MismatchedCollectionQueryUpdate"
  },
  "hash": "3f7050f51b9757c39599c5f76a8b9cb54870484c9f92fe6c66a9827c033c7291"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Mismatched query and update of collection",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Contents of collection 'codeLensSuppliersById' are queried, but never updated",
  "detailsInfo": "Reports collections whose contents are either queried and not updated, or updated and not queried.\n\n\nSuch inconsistent queries and updates are pointless and may indicate\neither dead code or a typo.\n\n\nUse the inspection settings to specify name patterns that correspond to update/query methods.\nQuery methods that return an element are automatically detected, and only\nthose that write data to an output parameter (for example, an `OutputStream`) need to be specified.\n\n\n**Example:**\n\nSuppose you have your custom `FixedStack` class with method `store()`:\n\n\n      public class FixedStack<T> extends Collection<T> {\n        public T store(T t) {\n          // implementation\n        }\n      }\n\nYou can add `store` to the update methods table in order to report mismatched queries like:\n\n\n      void test(int i) {\n        FixedStack<Integer> stack = new FixedStack<>();\n        stack.store(i);\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/providers/CodeLensProvider.java",
      "language": "JAVA",
      "line": 60,
      "offset": 61,
      "length": 21,
      "code": {
        "startLine": 58,
        "length": 21,
        "offset": 117,
        "surroundingCode": "@RequiredArgsConstructor\npublic class CodeLensProvider {\n  private final Map<String, CodeLensSupplier<CodeLensData>> codeLensSuppliersById;\n  private final ObjectProvider<List<CodeLensSupplier<CodeLensData>>> enabledCodeLensSuppliersProvider;\n  private final LanguageClientHolder clientHolder;"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "MismatchedCollectionQueryUpdate"
  },
  "hash": "56b19f493f1606298b75475c552ea6df2743f54456e927234c0cfb682f818fee"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Mismatched query and update of collection",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Contents of collection 'commandSuppliersById' are queried, but never updated",
  "detailsInfo": "Reports collections whose contents are either queried and not updated, or updated and not queried.\n\n\nSuch inconsistent queries and updates are pointless and may indicate\neither dead code or a typo.\n\n\nUse the inspection settings to specify name patterns that correspond to update/query methods.\nQuery methods that return an element are automatically detected, and only\nthose that write data to an output parameter (for example, an `OutputStream`) need to be specified.\n\n\n**Example:**\n\nSuppose you have your custom `FixedStack` class with method `store()`:\n\n\n      public class FixedStack<T> extends Collection<T> {\n        public T store(T t) {\n          // implementation\n        }\n      }\n\nYou can add `store` to the update methods table in order to report mismatched queries like:\n\n\n      void test(int i) {\n        FixedStack<Integer> stack = new FixedStack<>();\n        stack.store(i);\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/providers/CommandProvider.java",
      "language": "JAVA",
      "line": 45,
      "offset": 64,
      "length": 20,
      "code": {
        "startLine": 43,
        "length": 20,
        "offset": 95,
        "surroundingCode": "public class CommandProvider {\n\n  private final Map<String, CommandSupplier<CommandArguments>> commandSuppliersById;\n  private final ObjectMapper objectMapper;\n"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "MismatchedCollectionQueryUpdate"
  },
  "hash": "674afe99fa57ff502d2c23943c66975dc545a827b5defd22193a9376fdda7ea0"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Mismatched query and update of collection",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Contents of collection 'foldingRangeSuppliers' are queried, but never updated",
  "detailsInfo": "Reports collections whose contents are either queried and not updated, or updated and not queried.\n\n\nSuch inconsistent queries and updates are pointless and may indicate\neither dead code or a typo.\n\n\nUse the inspection settings to specify name patterns that correspond to update/query methods.\nQuery methods that return an element are automatically detected, and only\nthose that write data to an output parameter (for example, an `OutputStream`) need to be specified.\n\n\n**Example:**\n\nSuppose you have your custom `FixedStack` class with method `store()`:\n\n\n      public class FixedStack<T> extends Collection<T> {\n        public T store(T t) {\n          // implementation\n        }\n      }\n\nYou can add `store` to the update methods table in order to report mismatched queries like:\n\n\n      void test(int i) {\n        FixedStack<Integer> stack = new FixedStack<>();\n        stack.store(i);\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/providers/FoldingRangeProvider.java",
      "language": "JAVA",
      "line": 38,
      "offset": 44,
      "length": 21,
      "code": {
        "startLine": 36,
        "length": 21,
        "offset": 86,
        "surroundingCode": "public final class FoldingRangeProvider {\n\n  private final List<FoldingRangeSupplier> foldingRangeSuppliers;\n\n  public List<FoldingRange> getFoldingRange(DocumentContext documentContext) {"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "MismatchedCollectionQueryUpdate"
  },
  "hash": "6ced002751a6c9fc06800aac967e8ce287eb2d7b5194c6968cfe7c01579fcfdb"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Mismatched query and update of collection",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Contents of collection 'diagnosticInfos' are queried, but never updated",
  "detailsInfo": "Reports collections whose contents are either queried and not updated, or updated and not queried.\n\n\nSuch inconsistent queries and updates are pointless and may indicate\neither dead code or a typo.\n\n\nUse the inspection settings to specify name patterns that correspond to update/query methods.\nQuery methods that return an element are automatically detected, and only\nthose that write data to an output parameter (for example, an `OutputStream`) need to be specified.\n\n\n**Example:**\n\nSuppose you have your custom `FixedStack` class with method `store()`:\n\n\n      public class FixedStack<T> extends Collection<T> {\n        public T store(T t) {\n          // implementation\n        }\n      }\n\nYou can add `store` to the update methods table in order to report mismatched queries like:\n\n\n      void test(int i) {\n        FixedStack<Integer> stack = new FixedStack<>();\n        stack.store(i);\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/reporters/SarifReporter.java",
      "language": "JAVA",
      "line": 96,
      "offset": 44,
      "length": 15,
      "code": {
        "startLine": 94,
        "length": 15,
        "offset": 103,
        "surroundingCode": "\n  private final LanguageServerConfiguration configuration;\n  private final Collection<DiagnosticInfo> diagnosticInfos;\n  private final ServerInfo serverInfo;\n"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "MismatchedCollectionQueryUpdate"
  },
  "hash": "86c7f6779be15d6f713de2cf6f7913b425857949a79991c50c2b56f8e1fa9384"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Mismatched query and update of collection",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Contents of collection 'diagnosticInfos' are queried, but never updated",
  "detailsInfo": "Reports collections whose contents are either queried and not updated, or updated and not queried.\n\n\nSuch inconsistent queries and updates are pointless and may indicate\neither dead code or a typo.\n\n\nUse the inspection settings to specify name patterns that correspond to update/query methods.\nQuery methods that return an element are automatically detected, and only\nthose that write data to an output parameter (for example, an `OutputStream`) need to be specified.\n\n\n**Example:**\n\nSuppose you have your custom `FixedStack` class with method `store()`:\n\n\n      public class FixedStack<T> extends Collection<T> {\n        public T store(T t) {\n          // implementation\n        }\n      }\n\nYou can add `store` to the update methods table in order to report mismatched queries like:\n\n\n      void test(int i) {\n        FixedStack<Integer> stack = new FixedStack<>();\n        stack.store(i);\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/diagnostics/infrastructure/DiagnosticBeanPostProcessor.java",
      "language": "JAVA",
      "line": 39,
      "offset": 69,
      "length": 15,
      "code": {
        "startLine": 37,
        "length": 15,
        "offset": 128,
        "surroundingCode": "\n  private final LanguageServerConfiguration configuration;\n  private final Map<Class<? extends BSLDiagnostic>, DiagnosticInfo> diagnosticInfos;\n\n  @Override"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "MismatchedCollectionQueryUpdate"
  },
  "hash": "8b708a4adba5274cc5a604822731c7d31c547d8588df430f8e1b96d5c870aa92"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Mismatched query and update of collection",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Contents of collection 'regionRanges' are updated, but never queried",
  "detailsInfo": "Reports collections whose contents are either queried and not updated, or updated and not queried.\n\n\nSuch inconsistent queries and updates are pointless and may indicate\neither dead code or a typo.\n\n\nUse the inspection settings to specify name patterns that correspond to update/query methods.\nQuery methods that return an element are automatically detected, and only\nthose that write data to an output parameter (for example, an `OutputStream`) need to be specified.\n\n\n**Example:**\n\nSuppose you have your custom `FixedStack` class with method `store()`:\n\n\n      public class FixedStack<T> extends Collection<T> {\n        public T store(T t) {\n          // implementation\n        }\n      }\n\nYou can add `store` to the update methods table in order to report mismatched queries like:\n\n\n      void test(int i) {\n        FixedStack<Integer> stack = new FixedStack<>();\n        stack.store(i);\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/folding/CodeBlockFoldingRangeSupplier.java",
      "language": "JAVA",
      "line": 54,
      "offset": 38,
      "length": 12,
      "code": {
        "startLine": 52,
        "length": 12,
        "offset": 50,
        "surroundingCode": "\n    @Getter\n    private final List<FoldingRange> regionRanges = new ArrayList<>();\n\n    @Override"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "MismatchedCollectionQueryUpdate"
  },
  "hash": "931811f3608f0ecd408afdcee60a1dc1e96963c566f030584855589c6c40cfa4"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Mismatched query and update of collection",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Contents of collection 'languageClientAwares' are queried, but never updated",
  "detailsInfo": "Reports collections whose contents are either queried and not updated, or updated and not queried.\n\n\nSuch inconsistent queries and updates are pointless and may indicate\neither dead code or a typo.\n\n\nUse the inspection settings to specify name patterns that correspond to update/query methods.\nQuery methods that return an element are automatically detected, and only\nthose that write data to an output parameter (for example, an `OutputStream`) need to be specified.\n\n\n**Example:**\n\nSuppose you have your custom `FixedStack` class with method `store()`:\n\n\n      public class FixedStack<T> extends Collection<T> {\n        public T store(T t) {\n          // implementation\n        }\n      }\n\nYou can add `store` to the update methods table in order to report mismatched queries like:\n\n\n      void test(int i) {\n        FixedStack<Integer> stack = new FixedStack<>();\n        stack.store(i);\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/websocket/LSPWebSocketEndpoint.java",
      "language": "JAVA",
      "line": 43,
      "offset": 43,
      "length": 20,
      "code": {
        "startLine": 41,
        "length": 20,
        "offset": 90,
        "surroundingCode": "\n  private final LanguageServer languageServer;\n  private final List<LanguageClientAware> languageClientAwares;\n\n  @Override"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "MismatchedCollectionQueryUpdate"
  },
  "hash": "abf4b3fd36aca42b5458b7eca30a6493e4f75d8bbdb2472ff8af1b182974b664"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Mismatched query and update of collection",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Contents of collection 'finders' are queried, but never updated",
  "detailsInfo": "Reports collections whose contents are either queried and not updated, or updated and not queried.\n\n\nSuch inconsistent queries and updates are pointless and may indicate\neither dead code or a typo.\n\n\nUse the inspection settings to specify name patterns that correspond to update/query methods.\nQuery methods that return an element are automatically detected, and only\nthose that write data to an output parameter (for example, an `OutputStream`) need to be specified.\n\n\n**Example:**\n\nSuppose you have your custom `FixedStack` class with method `store()`:\n\n\n      public class FixedStack<T> extends Collection<T> {\n        public T store(T t) {\n          // implementation\n        }\n      }\n\nYou can add `store` to the update methods table in order to report mismatched queries like:\n\n\n      void test(int i) {\n        FixedStack<Integer> stack = new FixedStack<>();\n        stack.store(i);\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/references/ReferenceResolver.java",
      "language": "JAVA",
      "line": 42,
      "offset": 39,
      "length": 7,
      "code": {
        "startLine": 40,
        "length": 7,
        "offset": 86,
        "surroundingCode": "   * Список конкретных поисковых движков.\n   */\n  private final List<ReferenceFinder> finders;\n\n  /**"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "MismatchedCollectionQueryUpdate"
  },
  "hash": "b5948c2fa325d88c98617924e598f91175277f1115ca876254c511590e29666e"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Mismatched query and update of collection",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Contents of collection 'filteredReporters' are queried, but never updated",
  "detailsInfo": "Reports collections whose contents are either queried and not updated, or updated and not queried.\n\n\nSuch inconsistent queries and updates are pointless and may indicate\neither dead code or a typo.\n\n\nUse the inspection settings to specify name patterns that correspond to update/query methods.\nQuery methods that return an element are automatically detected, and only\nthose that write data to an output parameter (for example, an `OutputStream`) need to be specified.\n\n\n**Example:**\n\nSuppose you have your custom `FixedStack` class with method `store()`:\n\n\n      public class FixedStack<T> extends Collection<T> {\n        public T store(T t) {\n          // implementation\n        }\n      }\n\nYou can add `store` to the update methods table in order to report mismatched queries like:\n\n\n      void test(int i) {\n        FixedStack<Integer> stack = new FixedStack<>();\n        stack.store(i);\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/reporters/ReportersAggregator.java",
      "language": "JAVA",
      "line": 46,
      "offset": 36,
      "length": 17,
      "code": {
        "startLine": 44,
        "length": 17,
        "offset": 144,
        "surroundingCode": "  @Lazy\n  // Don't remove @Autowired annotation. It's needed for injecting filteredReporters bean correctly.\n  private List<DiagnosticReporter> filteredReporters;\n\n  public void report(AnalysisInfo analysisInfo, Path outputDir) {"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "MismatchedCollectionQueryUpdate"
  },
  "hash": "d15acb8b7f7932122a92996b4039ddb46a7a3359060f098085c3c54a58a42765"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Mismatched query and update of collection",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Contents of collection 'codeActionSuppliers' are queried, but never updated",
  "detailsInfo": "Reports collections whose contents are either queried and not updated, or updated and not queried.\n\n\nSuch inconsistent queries and updates are pointless and may indicate\neither dead code or a typo.\n\n\nUse the inspection settings to specify name patterns that correspond to update/query methods.\nQuery methods that return an element are automatically detected, and only\nthose that write data to an output parameter (for example, an `OutputStream`) need to be specified.\n\n\n**Example:**\n\nSuppose you have your custom `FixedStack` class with method `store()`:\n\n\n      public class FixedStack<T> extends Collection<T> {\n        public T store(T t) {\n          // implementation\n        }\n      }\n\nYou can add `store` to the update methods table in order to report mismatched queries like:\n\n\n      void test(int i) {\n        FixedStack<Integer> stack = new FixedStack<>();\n        stack.store(i);\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/providers/CodeActionProvider.java",
      "language": "JAVA",
      "line": 49,
      "offset": 42,
      "length": 19,
      "code": {
        "startLine": 47,
        "length": 19,
        "offset": 82,
        "surroundingCode": "public final class CodeActionProvider {\n\n  private final List<CodeActionSupplier> codeActionSuppliers;\n\n  public static List<CodeAction> createCodeActions("
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "MismatchedCollectionQueryUpdate"
  },
  "hash": "d9695ece00bef96602fca16c05bd0e6e565b4e3b8c93446a00d53a8780dca935"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Mismatched query and update of collection",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Contents of collection 'diagnosticInfos' are queried, but never updated",
  "detailsInfo": "Reports collections whose contents are either queried and not updated, or updated and not queried.\n\n\nSuch inconsistent queries and updates are pointless and may indicate\neither dead code or a typo.\n\n\nUse the inspection settings to specify name patterns that correspond to update/query methods.\nQuery methods that return an element are automatically detected, and only\nthose that write data to an output parameter (for example, an `OutputStream`) need to be specified.\n\n\n**Example:**\n\nSuppose you have your custom `FixedStack` class with method `store()`:\n\n\n      public class FixedStack<T> extends Collection<T> {\n        public T store(T t) {\n          // implementation\n        }\n      }\n\nYou can add `store` to the update methods table in order to report mismatched queries like:\n\n\n      void test(int i) {\n        FixedStack<Integer> stack = new FixedStack<>();\n        stack.store(i);\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/codeactions/QuickFixSupplier.java",
      "language": "JAVA",
      "line": 40,
      "offset": 45,
      "length": 15,
      "code": {
        "startLine": 38,
        "length": 15,
        "offset": 77,
        "surroundingCode": "public class QuickFixSupplier {\n\n  private final Map<String, DiagnosticInfo> diagnosticInfos;\n  private final DiagnosticObjectProvider diagnosticObjectProvider;\n"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "MismatchedCollectionQueryUpdate"
  },
  "hash": "e02a4259ef6103467bd9ec03a0ad22f4c49dc4ba34d8a710010da39f42db4acf"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Mismatched query and update of collection",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Contents of collection 'diagnosticIgnorance' are queried, but never updated",
  "detailsInfo": "Reports collections whose contents are either queried and not updated, or updated and not queried.\n\n\nSuch inconsistent queries and updates are pointless and may indicate\neither dead code or a typo.\n\n\nUse the inspection settings to specify name patterns that correspond to update/query methods.\nQuery methods that return an element are automatically detected, and only\nthose that write data to an output parameter (for example, an `OutputStream`) need to be specified.\n\n\n**Example:**\n\nSuppose you have your custom `FixedStack` class with method `store()`:\n\n\n      public class FixedStack<T> extends Collection<T> {\n        public T store(T t) {\n          // implementation\n        }\n      }\n\nYou can add `store` to the update methods table in order to report mismatched queries like:\n\n\n      void test(int i) {\n        FixedStack<Integer> stack = new FixedStack<>();\n        stack.store(i);\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/context/computer/DiagnosticIgnoranceComputer.java",
      "language": "JAVA",
      "line": 247,
      "offset": 61,
      "length": 19,
      "code": {
        "startLine": 245,
        "length": 19,
        "offset": 111,
        "surroundingCode": "  @AllArgsConstructor\n  public static class Data {\n    private final Map<DiagnosticCode, List<Range<Integer>>> diagnosticIgnorance;\n\n    public boolean diagnosticShouldBeIgnored(Diagnostic diagnostic) {"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "MismatchedCollectionQueryUpdate"
  },
  "hash": "e35b8374467357b78d6c9b9a7dcf6fa6cbebe620a74300a5b540a2de73eede48"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Mismatched query and update of collection",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Contents of collection 'regionRanges' are updated, but never queried",
  "detailsInfo": "Reports collections whose contents are either queried and not updated, or updated and not queried.\n\n\nSuch inconsistent queries and updates are pointless and may indicate\neither dead code or a typo.\n\n\nUse the inspection settings to specify name patterns that correspond to update/query methods.\nQuery methods that return an element are automatically detected, and only\nthose that write data to an output parameter (for example, an `OutputStream`) need to be specified.\n\n\n**Example:**\n\nSuppose you have your custom `FixedStack` class with method `store()`:\n\n\n      public class FixedStack<T> extends Collection<T> {\n        public T store(T t) {\n          // implementation\n        }\n      }\n\nYou can add `store` to the update methods table in order to report mismatched queries like:\n\n\n      void test(int i) {\n        FixedStack<Integer> stack = new FixedStack<>();\n        stack.store(i);\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/folding/PreprocIfFoldingRangeSupplier.java",
      "language": "JAVA",
      "line": 54,
      "offset": 38,
      "length": 12,
      "code": {
        "startLine": 52,
        "length": 12,
        "offset": 50,
        "surroundingCode": "\n    @Getter\n    private final List<FoldingRange> regionRanges = new ArrayList<>();\n    private final Deque<BSLParser.Preproc_ifContext> preprocIfRegionStack = new ArrayDeque<>();\n"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "MismatchedCollectionQueryUpdate"
  },
  "hash": "e3d7abe4e2d44a7533869df3ed567b00ad0e3700ef8ff55e9b487858d9676179"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Mismatched query and update of collection",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Contents of collection 'suppliers' are queried, but never updated",
  "detailsInfo": "Reports collections whose contents are either queried and not updated, or updated and not queried.\n\n\nSuch inconsistent queries and updates are pointless and may indicate\neither dead code or a typo.\n\n\nUse the inspection settings to specify name patterns that correspond to update/query methods.\nQuery methods that return an element are automatically detected, and only\nthose that write data to an output parameter (for example, an `OutputStream`) need to be specified.\n\n\n**Example:**\n\nSuppose you have your custom `FixedStack` class with method `store()`:\n\n\n      public class FixedStack<T> extends Collection<T> {\n        public T store(T t) {\n          // implementation\n        }\n      }\n\nYou can add `store` to the update methods table in order to report mismatched queries like:\n\n\n      void test(int i) {\n        FixedStack<Integer> stack = new FixedStack<>();\n        stack.store(i);\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/providers/DocumentLinkProvider.java",
      "language": "JAVA",
      "line": 40,
      "offset": 50,
      "length": 9,
      "code": {
        "startLine": 38,
        "length": 9,
        "offset": 110,
        "surroundingCode": "@RequiredArgsConstructor\npublic class DocumentLinkProvider {\n  private final Collection<DocumentLinkSupplier> suppliers;\n\n  public List<DocumentLink> getDocumentLinks(DocumentContext documentContext) {"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "MismatchedCollectionQueryUpdate"
  },
  "hash": "e87b1d7c4b8b4b41cdf75d239aacd36a819f68371b80db102c740fcd4c0d35a0"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Mismatched query and update of collection",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "Contents of collection 'issues' are updated, but never queried",
  "detailsInfo": "Reports collections whose contents are either queried and not updated, or updated and not queried.\n\n\nSuch inconsistent queries and updates are pointless and may indicate\neither dead code or a typo.\n\n\nUse the inspection settings to specify name patterns that correspond to update/query methods.\nQuery methods that return an element are automatically detected, and only\nthose that write data to an output parameter (for example, an `OutputStream`) need to be specified.\n\n\n**Example:**\n\nSuppose you have your custom `FixedStack` class with method `store()`:\n\n\n      public class FixedStack<T> extends Collection<T> {\n        public T store(T t) {\n          // implementation\n        }\n      }\n\nYou can add `store` to the update methods table in order to report mismatched queries like:\n\n\n      void test(int i) {\n        FixedStack<Integer> stack = new FixedStack<>();\n        stack.store(i);\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/reporters/GenericIssueReport.java",
      "language": "JAVA",
      "line": 55,
      "offset": 41,
      "length": 6,
      "code": {
        "startLine": 53,
        "length": 6,
        "offset": 76,
        "surroundingCode": "  @Getter\n  @JsonProperty(\"issues\")\n  private final List<GenericIssueEntry> issues;\n\n  public GenericIssueReport("
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "MismatchedCollectionQueryUpdate"
  },
  "hash": "f5f073e1910b1e156dc4195efce13dc1fff116a02af57ddf840b21db3eb68629"
},{
  "tool": "Code Inspection",
  "category": "Serialization issues",
  "type": "'@Serial' annotation could be used",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "'serialVersionUID' can be annotated with '@Serial' annotation",
  "detailsInfo": "Reports methods and fields in the `Serializable` and `Externalizable` classes that are suitable to be annotated with the `java.io.Serial` annotation. The quick-fix adds the annotation.\n\n**Example:**\n\n\n    class Main implements Serializable {\n      private static final long serialVersionUID = 7874493593505141603L;\n\n      private void writeObject(ObjectOutputStream out) throws IOException {\n      }\n    }\n\nAfter the quick-fix is applied:\n\n\n      class Main implements Serializable {\n        @Serial\n        private static final long serialVersionUID = 7874493593505141603L;\n\n        @Serial\n        private void writeObject(ObjectOutputStream out) throws IOException {\n        }\n    }\n\n**Example:**\n\n\n      class Main implements Externalizable {\n        protected Object readResolve() throws ObjectStreamException {\n          return \"SomeObject\";\n        }\n      }\n\nAfter the quick-fix is applied:\n\n\n      class Main implements Externalizable {\n        @Serial\n        protected Object readResolve() throws ObjectStreamException {\n            return \"SomeObject\";\n        }\n      }\n\nFor more information about all possible cases, refer the documentation for `java.io.Serial`.\n\nThis inspection only reports if the language level of the project or module is 14 or higher.\n\nNew in 2020.3",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/configuration/events/LanguageServerConfigurationChangedEvent.java",
      "language": "JAVA",
      "line": 34,
      "offset": 29,
      "length": 16,
      "code": {
        "startLine": 32,
        "length": 16,
        "offset": 109,
        "surroundingCode": "public class LanguageServerConfigurationChangedEvent extends ApplicationEvent {\n\n  private static final long serialVersionUID = 649143503434640953L;\n\n  public LanguageServerConfigurationChangedEvent(LanguageServerConfiguration configuration) {"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "MissingSerialAnnotation"
  },
  "hash": "106f26b585e933e5774e266ea29de3044f718fe3eeb0e1868d97ec54e03636ea"
},{
  "tool": "Code Inspection",
  "category": "Serialization issues",
  "type": "'@Serial' annotation could be used",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "'serialVersionUID' can be annotated with '@Serial' annotation",
  "detailsInfo": "Reports methods and fields in the `Serializable` and `Externalizable` classes that are suitable to be annotated with the `java.io.Serial` annotation. The quick-fix adds the annotation.\n\n**Example:**\n\n\n    class Main implements Serializable {\n      private static final long serialVersionUID = 7874493593505141603L;\n\n      private void writeObject(ObjectOutputStream out) throws IOException {\n      }\n    }\n\nAfter the quick-fix is applied:\n\n\n      class Main implements Serializable {\n        @Serial\n        private static final long serialVersionUID = 7874493593505141603L;\n\n        @Serial\n        private void writeObject(ObjectOutputStream out) throws IOException {\n        }\n    }\n\n**Example:**\n\n\n      class Main implements Externalizable {\n        protected Object readResolve() throws ObjectStreamException {\n          return \"SomeObject\";\n        }\n      }\n\nAfter the quick-fix is applied:\n\n\n      class Main implements Externalizable {\n        @Serial\n        protected Object readResolve() throws ObjectStreamException {\n            return \"SomeObject\";\n        }\n      }\n\nFor more information about all possible cases, refer the documentation for `java.io.Serial`.\n\nThis inspection only reports if the language level of the project or module is 14 or higher.\n\nNew in 2020.3",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/context/events/DocumentContextContentChangedEvent.java",
      "language": "JAVA",
      "line": 29,
      "offset": 29,
      "length": 16,
      "code": {
        "startLine": 27,
        "length": 16,
        "offset": 104,
        "surroundingCode": "public class DocumentContextContentChangedEvent extends ApplicationEvent {\n\n  private static final long serialVersionUID = 3091414460731918073L;\n\n  public DocumentContextContentChangedEvent(DocumentContext source) {"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "MissingSerialAnnotation"
  },
  "hash": "9be980b05c2537cfcb0743411607734fbe1bf3ab6db0684d31631d98a1039ab9"
},{
  "tool": "Code Inspection",
  "category": "Serialization issues",
  "type": "'@Serial' annotation could be used",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "'serialVersionUID' can be annotated with '@Serial' annotation",
  "detailsInfo": "Reports methods and fields in the `Serializable` and `Externalizable` classes that are suitable to be annotated with the `java.io.Serial` annotation. The quick-fix adds the annotation.\n\n**Example:**\n\n\n    class Main implements Serializable {\n      private static final long serialVersionUID = 7874493593505141603L;\n\n      private void writeObject(ObjectOutputStream out) throws IOException {\n      }\n    }\n\nAfter the quick-fix is applied:\n\n\n      class Main implements Serializable {\n        @Serial\n        private static final long serialVersionUID = 7874493593505141603L;\n\n        @Serial\n        private void writeObject(ObjectOutputStream out) throws IOException {\n        }\n    }\n\n**Example:**\n\n\n      class Main implements Externalizable {\n        protected Object readResolve() throws ObjectStreamException {\n          return \"SomeObject\";\n        }\n      }\n\nAfter the quick-fix is applied:\n\n\n      class Main implements Externalizable {\n        @Serial\n        protected Object readResolve() throws ObjectStreamException {\n            return \"SomeObject\";\n        }\n      }\n\nFor more information about all possible cases, refer the documentation for `java.io.Serial`.\n\nThis inspection only reports if the language level of the project or module is 14 or higher.\n\nNew in 2020.3",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/context/events/ServerContextPopulatedEvent.java",
      "language": "JAVA",
      "line": 29,
      "offset": 29,
      "length": 16,
      "code": {
        "startLine": 27,
        "length": 16,
        "offset": 97,
        "surroundingCode": "public class ServerContextPopulatedEvent extends ApplicationEvent {\n\n  private static final long serialVersionUID = -4485675935728156708L;\n\n  public ServerContextPopulatedEvent(ServerContext source) {"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "MissingSerialAnnotation"
  },
  "hash": "ad0974a6c2243670178495f61c583f8d71ea6d8450acc2f17f5bdb59d748fd30"
},{
  "tool": "Code Inspection",
  "category": "Serialization issues",
  "type": "'@Serial' annotation could be used",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "'serialVersionUID' can be annotated with '@Serial' annotation",
  "detailsInfo": "Reports methods and fields in the `Serializable` and `Externalizable` classes that are suitable to be annotated with the `java.io.Serial` annotation. The quick-fix adds the annotation.\n\n**Example:**\n\n\n    class Main implements Serializable {\n      private static final long serialVersionUID = 7874493593505141603L;\n\n      private void writeObject(ObjectOutputStream out) throws IOException {\n      }\n    }\n\nAfter the quick-fix is applied:\n\n\n      class Main implements Serializable {\n        @Serial\n        private static final long serialVersionUID = 7874493593505141603L;\n\n        @Serial\n        private void writeObject(ObjectOutputStream out) throws IOException {\n        }\n    }\n\n**Example:**\n\n\n      class Main implements Externalizable {\n        protected Object readResolve() throws ObjectStreamException {\n          return \"SomeObject\";\n        }\n      }\n\nAfter the quick-fix is applied:\n\n\n      class Main implements Externalizable {\n        @Serial\n        protected Object readResolve() throws ObjectStreamException {\n            return \"SomeObject\";\n        }\n      }\n\nFor more information about all possible cases, refer the documentation for `java.io.Serial`.\n\nThis inspection only reports if the language level of the project or module is 14 or higher.\n\nNew in 2020.3",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/events/LanguageServerInitializeRequestReceivedEvent.java",
      "language": "JAVA",
      "line": 36,
      "offset": 29,
      "length": 16,
      "code": {
        "startLine": 34,
        "length": 16,
        "offset": 114,
        "surroundingCode": "public class LanguageServerInitializeRequestReceivedEvent extends ApplicationEvent {\n\n  private static final long serialVersionUID = 7153531865051478056L;\n\n  /**"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "MissingSerialAnnotation"
  },
  "hash": "c8e898133b1bd904acc5eeb3982546589c7926b0b578b56666c7d4ca4aef1d76"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Suspicious collection method call",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "'Map' may not contain keys of type ''",
  "detailsInfo": "Reports method calls on parameterized collections, where the actual argument type does not correspond to the collection's elements type.\n\n**Example:**\n\n\n      List<Integer> list = getListOfElements();\n      list.remove(\"\"); // remove is highlighted\n\n\nIn the inspection settings, you can disable warnings for potentially correct code like the following:\n\n\n      public boolean accept(Map<Integer, String> map, Object key) {\n        return map.containsKey(key);\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/codelenses/AbstractMethodComplexityCodeLensSupplier.java",
      "language": "JAVA",
      "line": 63,
      "offset": 53,
      "length": 12,
      "code": {
        "startLine": 61,
        "length": 12,
        "offset": 184,
        "surroundingCode": "    var methodsComplexity = getMethodsComplexity(documentContext);\n    return documentContext.getSymbolTree().getMethods().stream()\n      .filter(methodSymbol -> methodsComplexity.get(methodSymbol) >= complexityThreshold)\n      .map(methodSymbol -> toCodeLens(methodSymbol, documentContext))\n      .collect(Collectors.toList());"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "SuspiciousMethodCalls"
  },
  "hash": "5ae24842abe0adb20afc3408df165816f3320c7b56f72c34af68c6980829594f"
},{
  "tool": "Code Inspection",
  "category": "Probable bugs",
  "type": "Suspicious collection method call",
  "tags": [
    "JAVA"
  ],
  "severity": "High",
  "comment": "'Map>' may not contain keys of type ''",
  "detailsInfo": "Reports method calls on parameterized collections, where the actual argument type does not correspond to the collection's elements type.\n\n**Example:**\n\n\n      List<Integer> list = getListOfElements();\n      list.remove(\"\"); // remove is highlighted\n\n\nIn the inspection settings, you can disable warnings for potentially correct code like the following:\n\n\n      public boolean accept(Map<Integer, String> map, Object key) {\n        return map.containsKey(key);\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/inlayhints/AbstractComplexityInlayHintSupplier.java",
      "language": "JAVA",
      "line": 64,
      "offset": 70,
      "length": 12,
      "code": {
        "startLine": 62,
        "length": 12,
        "offset": 171,
        "surroundingCode": "      .filter(entry -> enabledMethodsInFile.contains(entry.getKey()))\n      .map(Map.Entry::getValue)\n      .map(methodSymbol -> cognitiveComplexityLocations.getOrDefault(methodSymbol, Collections.emptyList()).stream()\n        .map(AbstractComplexityInlayHintSupplier::toInlayHint)\n        .collect(Collectors.toList()))"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "SuspiciousMethodCalls"
  },
  "hash": "e33ce1e65c901d4dd6289af57ef58dbb6532f08ec81324001adcc56441d71cfe"
}]}