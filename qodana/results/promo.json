{"version":"3","listProblem":[{
  "tool": "Code Inspection",
  "category": "Code style issues",
  "type": "Field may be 'final'",
  "severity": "High",
  "comment": "Field `endpointPath` may be 'final'",
  "detailsInfo": "Reports fields that can be safely made `final`. All `final` fields have a value and this value does not change, which can make the code easier to reason about.\n\nTo avoid too expensive analysis, this inspection only reports if the field has a `private` modifier\nor it is defined in a local or anonymous class.\nA field can be `final` if:\n\n* It is `static` and initialized once in its declaration or in one `static` initializer.\n* It is non-`static` and initialized once in its declaration, in one instance initializer or in every constructor\n\nAnd it is not modified anywhere else.\n\n**Example:**\n\n\n      public class Person {\n        private String name; // can be final\n\n        Person(String name) {\n          this.name = name;\n        }\n\n        public String getName() {\n          return name;\n        }\n      }\n\nAfter the quick-fix is applied:\n\n\n      public class Person {\n        private final String name;\n\n        Person(String name) {\n          this.name = name;\n        }\n\n        public String getName() {\n          return name;\n        }\n      }\n\n\nUse the \"Annotations\" button to modify the list of annotations that assume implicit field write.",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/websocket/WebSocketConfiguration.java",
      "language": "JAVA",
      "line": 44,
      "offset": 18,
      "length": 12,
      "code": {
        "startLine": 42,
        "length": 12,
        "offset": 56,
        "surroundingCode": "\n  @Value(\"${app.websocket.lsp-path}\")\n  private String endpointPath = \"\";\n\n  @Bean"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "FieldMayBeFinal"
  },
  "hash": "9e90f205d2530bb6c80c1b7e110aea51c6c9579943223925e6c150d8c8c6b449"
},{
  "tool": "Code Inspection",
  "category": "Code style issues",
  "type": "Field may be 'final'",
  "severity": "High",
  "comment": "Field `allowOneliner` may be 'final'",
  "detailsInfo": "Reports fields that can be safely made `final`. All `final` fields have a value and this value does not change, which can make the code easier to reason about.\n\nTo avoid too expensive analysis, this inspection only reports if the field has a `private` modifier\nor it is defined in a local or anonymous class.\nA field can be `final` if:\n\n* It is `static` and initialized once in its declaration or in one `static` initializer.\n* It is non-`static` and initialized once in its declaration, in one instance initializer or in every constructor\n\nAnd it is not modified anywhere else.\n\n**Example:**\n\n\n      public class Person {\n        private String name; // can be final\n\n        Person(String name) {\n          this.name = name;\n        }\n\n        public String getName() {\n          return name;\n        }\n      }\n\nAfter the quick-fix is applied:\n\n\n      public class Person {\n        private final String name;\n\n        Person(String name) {\n          this.name = name;\n        }\n\n        public String getName() {\n          return name;\n        }\n      }\n\n\nUse the \"Annotations\" button to modify the list of annotations that assume implicit field write.",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/diagnostics/NestedFunctionInParametersDiagnostic.java",
      "language": "JAVA",
      "line": 61,
      "offset": 19,
      "length": 13,
      "code": {
        "startLine": 59,
        "length": 13,
        "offset": 69,
        "surroundingCode": "    defaultValue = \"\" + DEFAULT_ALLOW_ONELINER\n  )\n  private boolean allowOneliner = DEFAULT_ALLOW_ONELINER;\n\n  @DiagnosticParameter("
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "FieldMayBeFinal"
  },
  "hash": "d90a0f8919473908e6206b92603c8afc258fd23f6f41953540f9809e8758dcfc"
},{
  "tool": "Code Inspection",
  "category": "Code style issues",
  "type": "Field may be 'final'",
  "severity": "High",
  "comment": "Field `allowedMethodNames` may be 'final'",
  "detailsInfo": "Reports fields that can be safely made `final`. All `final` fields have a value and this value does not change, which can make the code easier to reason about.\n\nTo avoid too expensive analysis, this inspection only reports if the field has a `private` modifier\nor it is defined in a local or anonymous class.\nA field can be `final` if:\n\n* It is `static` and initialized once in its declaration or in one `static` initializer.\n* It is non-`static` and initialized once in its declaration, in one instance initializer or in every constructor\n\nAnd it is not modified anywhere else.\n\n**Example:**\n\n\n      public class Person {\n        private String name; // can be final\n\n        Person(String name) {\n          this.name = name;\n        }\n\n        public String getName() {\n          return name;\n        }\n      }\n\nAfter the quick-fix is applied:\n\n\n      public class Person {\n        private final String name;\n\n        Person(String name) {\n          this.name = name;\n        }\n\n        public String getName() {\n          return name;\n        }\n      }\n\n\nUse the \"Annotations\" button to modify the list of annotations that assume implicit field write.",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/diagnostics/NestedFunctionInParametersDiagnostic.java",
      "language": "JAVA",
      "line": 67,
      "offset": 18,
      "length": 18,
      "code": {
        "startLine": 65,
        "length": 18,
        "offset": 61,
        "surroundingCode": "    defaultValue = ALLOWED_METHOD_NAMES\n  )\n  private String allowedMethodNames = ALLOWED_METHOD_NAMES;\n\n  private static Pattern compilePattern(String allowedNames) {"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "FieldMayBeFinal"
  },
  "hash": "f8b9804f03041b68ebce3381e3e4dd1d9bb83018f973b5e5095ade042b3afb0d"
},{
  "tool": "Code Inspection",
  "category": "Verbose or redundant code constructs",
  "type": "Lombok @Getter may be used",
  "severity": "High",
  "comment": "Class 'DiagnosticTag' may use Lombok @Getter",
  "detailsInfo": "Reports standard getter method that can be replaced by the lombok `@Getter` annotation.\n\nExample:\n\n\n      import java.util.Date;\n\n      public class MyClass {\n        /**\n         * The process date.\n         */\n        private Date processDate;\n\n        /**\n         * Returns the date.\n         *\n         * @return The date\n         */\n        public Date getProcessDate() {\n          return processDate;\n        }\n      }\n\nAfter the quick-fix/cleanup is applied:\n\n\n      import lombok.Getter;\n      import java.util.Date;\n\n      @Getter\n      public class MyClass {\n        /**\n         * The process date.\n         * -- GETTER --\n         * Returns the date.\n         *\n         * @return The date\n         */\n        private Date processDate;\n      }\n\nIt only reports when the lombok library is configured. To unlombok, see the lombok site.\n\nNew in 2023.2",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/diagnostics/metadata/DiagnosticTag.java",
      "language": "JAVA",
      "line": 24,
      "offset": 13,
      "length": 13,
      "code": {
        "startLine": 22,
        "length": 13,
        "offset": 84,
        "surroundingCode": "package com.github._1c_syntax.bsl.languageserver.diagnostics.metadata;\n\npublic enum DiagnosticTag {\n  STANDARD(\"Нарушение стандартов 1С\"),\n  LOCKINOS(\"Не будет работать в другой ОС\"),"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "LombokGetterMayBeUsed"
  },
  "hash": "0d616415c408a1dae83ca9ef7656a578ee30e08afb5d07f0d84f7d9b491f1988"
},{
  "tool": "Code Inspection",
  "category": "Verbose or redundant code constructs",
  "type": "Lombok @Getter may be used",
  "severity": "High",
  "comment": "Class 'TSLintReportEntry' may use Lombok @Getter",
  "detailsInfo": "Reports standard getter method that can be replaced by the lombok `@Getter` annotation.\n\nExample:\n\n\n      import java.util.Date;\n\n      public class MyClass {\n        /**\n         * The process date.\n         */\n        private Date processDate;\n\n        /**\n         * Returns the date.\n         *\n         * @return The date\n         */\n        public Date getProcessDate() {\n          return processDate;\n        }\n      }\n\nAfter the quick-fix/cleanup is applied:\n\n\n      import lombok.Getter;\n      import java.util.Date;\n\n      @Getter\n      public class MyClass {\n        /**\n         * The process date.\n         * -- GETTER --\n         * Returns the date.\n         *\n         * @return The date\n         */\n        private Date processDate;\n      }\n\nIt only reports when the lombok library is configured. To unlombok, see the lombok site.\n\nNew in 2023.2",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/reporters/TSLintReportEntry.java",
      "language": "JAVA",
      "line": 33,
      "offset": 7,
      "length": 17,
      "code": {
        "startLine": 31,
        "length": 17,
        "offset": 29,
        "surroundingCode": "import java.util.Map;\n\nclass TSLintReportEntry {\n  @Getter\n  private final EntryPosition startPosition;"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "LombokGetterMayBeUsed"
  },
  "hash": "1459d4fde1eeb6551ecdf5a9e504bcd437e8e3489271710f4bb60d388a2f1398"
},{
  "tool": "Code Inspection",
  "category": "Verbose or redundant code constructs",
  "type": "Lombok @Getter may be used",
  "severity": "High",
  "comment": "Class 'EntryPosition' may use Lombok @Getter",
  "detailsInfo": "Reports standard getter method that can be replaced by the lombok `@Getter` annotation.\n\nExample:\n\n\n      import java.util.Date;\n\n      public class MyClass {\n        /**\n         * The process date.\n         */\n        private Date processDate;\n\n        /**\n         * Returns the date.\n         *\n         * @return The date\n         */\n        public Date getProcessDate() {\n          return processDate;\n        }\n      }\n\nAfter the quick-fix/cleanup is applied:\n\n\n      import lombok.Getter;\n      import java.util.Date;\n\n      @Getter\n      public class MyClass {\n        /**\n         * The process date.\n         * -- GETTER --\n         * Returns the date.\n         *\n         * @return The date\n         */\n        private Date processDate;\n      }\n\nIt only reports when the lombok library is configured. To unlombok, see the lombok site.\n\nNew in 2023.2",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/reporters/TSLintReportEntry.java",
      "language": "JAVA",
      "line": 81,
      "offset": 16,
      "length": 13,
      "code": {
        "startLine": 79,
        "length": 13,
        "offset": 20,
        "surroundingCode": "  }\n\n  static class EntryPosition {\n    @Getter\n    private final int character;"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "LombokGetterMayBeUsed"
  },
  "hash": "389d43cc8a15b52d6341b391861147e57c25f8066c96cc255dfddb0983a0f7f5"
},{
  "tool": "Code Inspection",
  "category": "Verbose or redundant code constructs",
  "type": "Lombok @Getter may be used",
  "severity": "High",
  "comment": "Field 'diagnosticClass' may have Lombok @Getter",
  "detailsInfo": "Reports standard getter method that can be replaced by the lombok `@Getter` annotation.\n\nExample:\n\n\n      import java.util.Date;\n\n      public class MyClass {\n        /**\n         * The process date.\n         */\n        private Date processDate;\n\n        /**\n         * Returns the date.\n         *\n         * @return The date\n         */\n        public Date getProcessDate() {\n          return processDate;\n        }\n      }\n\nAfter the quick-fix/cleanup is applied:\n\n\n      import lombok.Getter;\n      import java.util.Date;\n\n      @Getter\n      public class MyClass {\n        /**\n         * The process date.\n         * -- GETTER --\n         * Returns the date.\n         *\n         * @return The date\n         */\n        private Date processDate;\n      }\n\nIt only reports when the lombok library is configured. To unlombok, see the lombok site.\n\nNew in 2023.2",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/diagnostics/metadata/DiagnosticInfo.java",
      "language": "JAVA",
      "line": 74,
      "offset": 3,
      "length": 92,
      "code": {
        "startLine": 72,
        "length": 92,
        "offset": 7,
        "surroundingCode": "  }\n\n  public Class<? extends BSLDiagnostic> getDiagnosticClass() {\n    return diagnosticClass;\n  }\n\n  public DiagnosticCode getCode() {"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "LombokGetterMayBeUsed"
  },
  "hash": "afa817331daddca3bda5e5b05870409d560d0c1c2d776634d471d359a4e6bc0e"
},{
  "tool": "Code Inspection",
  "category": "Verbose or redundant code constructs",
  "type": "Stream API call chain can be simplified",
  "severity": "High",
  "comment": "'collect(toList())' can be replaced with 'toList()'",
  "detailsInfo": "Reports stream API call chains that can be simplified. Simplification will often avoid some temporary object creation during collection traversal.\n\n\nThe inspection replaces the following call chains:\n\n* `collection.stream().forEach()` → `collection.forEach()`\n* `collection.stream().collect(toList/toSet/toCollection())` → `new CollectionType<>(collection)`\n* `collection.stream().toArray()` → `collection.toArray()`\n* `Arrays.asList().stream()` → `Arrays.stream()` or `Stream.of()`\n* `IntStream.range(0, array.length).mapToObj(idx -> array[idx])` → `Arrays.stream(array)`\n* `IntStream.range(0, list.size()).mapToObj(idx -> list.get(idx))` → `list.stream()`\n* `Collections.singleton().stream()` → `Stream.of()`\n* `Collections.emptyList().stream()` → `Stream.empty()`\n* `stream.filter().findFirst().isPresent()` → `stream.anyMatch()`\n* `stream.collect(counting())` → `stream.count()`\n* `stream.collect(maxBy())` → `stream.max()`\n* `stream.collect(mapping())` → `stream.map().collect()`\n* `stream.collect(reducing())` → `stream.reduce()`\n* `stream.collect(summingInt())` → `stream.mapToInt().sum()`\n* `stream.mapToObj(x -> x)` → `stream.boxed()`\n* `stream.map(x -> {...; return x;})` → `stream.peek(x -> ...)`\n* `!stream.anyMatch()` → `stream.noneMatch()`\n* `!stream.anyMatch(x -> !(...))` → `stream.allMatch()`\n* `stream.map().anyMatch(Boolean::booleanValue)` → `stream.anyMatch()`\n* `IntStream.range(expr1, expr2).mapToObj(x -> array[x])` → `Arrays.stream(array, expr1, expr2)`\n* `Collection.nCopies(count, ...)` → `Stream.generate().limit(count)`\n* `stream.sorted(comparator).findFirst()` → `Stream.min(comparator)`\n* `optional.orElseGet(() -> { throw new ...; })` → `optional.orElseThrow()`\n\n\nNote that the replacement semantics may have minor differences in some cases. For example,\n`Collections.synchronizedList(...).stream().forEach()` is not synchronized while\n`Collections.synchronizedList(...).forEach()` is synchronized.\nAlso, `collect(Collectors.maxBy())` returns an empty `Optional` if the resulting element is\n`null` while `Stream.max()` throws `NullPointerException` in this case.",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/diagnostics/CommentedCodeDiagnostic.java",
      "language": "JAVA",
      "line": 207,
      "offset": 10,
      "length": 28,
      "code": {
        "startLine": 205,
        "length": 28,
        "offset": 87,
        "surroundingCode": "        .map(Token::getType)\n        .filter(t -> t != BSLParser.WHITE_SPACE)\n        .collect(Collectors.toList());\n\n      // Если два идентификатора идут подряд - это не код"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "SimplifyStreamApiCallChains"
  },
  "hash": "29fc005010c69992eed7ddc81a47150a7f36ce1881670170a60dca727a13901d"
},{
  "tool": "Code Inspection",
  "category": "Verbose or redundant code constructs",
  "type": "Concatenation with empty string",
  "severity": "High",
  "comment": "Empty string in concatenation",
  "detailsInfo": "Reports empty string operands in string concatenations. Concatenation with the empty string can be used to convert non-`String` objects or primitives into `String`s, but it can be clearer to use a `String.valueOf()` method call.\n\n\nA quick-fix is suggested to simplify the concatenation.\n\n**Example:**\n\n\n      void foo(int x, int y) {\n        String s = \"\" + x + \" ; \" + y;\n      }\n\nAfter the quick-fix is applied:\n\n\n      void foo(int x, int y) {\n        String s = x + \" ; \" + y;\n      }\n\n\nUse the **Report only where empty strings can be removed without other changes**\noption to ignore cases cases where removing the empty string\nwill require adding a `String.valueOf()` conversion of another operand.",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/diagnostics/UsingServiceTagDiagnostic.java",
      "language": "JAVA",
      "line": 52,
      "offset": 20,
      "length": 2,
      "code": {
        "startLine": 50,
        "length": 2,
        "offset": 68,
        "surroundingCode": "  @DiagnosticParameter(\n    type = String.class,\n    defaultValue = \"\" + SERVICE_TAGS_DEFAULT\n  )\n  private String serviceTags = SERVICE_TAGS_DEFAULT;"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "TrivialStringConcatenation"
  },
  "hash": "740e8e0f601e64bec4882661cd63a5ea5e459eccad9e1b248e430274107d8b5c"
},{
  "tool": "Code Inspection",
  "category": "Imports",
  "type": "Unused import",
  "severity": "High",
  "comment": "Unused import `import org.eclipse.lsp4j.InitializeParams;`",
  "detailsInfo": "Reports redundant `import` statements.\n\nRegular `import` statements are unnecessary when not using imported classes and packages in the source file.\nThe same applies to imported `static` fields and methods that aren't used in the source file.\n\n**Example:**\n\n\n      import java.util.ArrayList;\n      public class Example {\n        public static void main(String[] args) {\n          System.out.println(\"Hello World!\");\n        }\n      }\n\nAfter the quick fix is applied:\n\n\n      public class Example {\n        public static void main(String[] args) {\n          System.out.println(\"Hello World!\");\n        }\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/codelenses/RunTestCodeLensSupplier.java",
      "language": "JAVA",
      "line": 39,
      "offset": 1,
      "length": 42,
      "code": {
        "startLine": 37,
        "length": 42,
        "offset": 69,
        "surroundingCode": "import org.eclipse.lsp4j.CodeLens;\nimport org.eclipse.lsp4j.Command;\nimport org.eclipse.lsp4j.InitializeParams;\nimport org.springframework.context.event.EventListener;\nimport org.springframework.stereotype.Component;"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "UNUSED_IMPORT"
  },
  "hash": "9200c3c9275942f2670217fe8ffbcc549f7ed26013189a082abeca9f65d6efea"
},{
  "tool": "Code Inspection",
  "category": "Imports",
  "type": "Unused import",
  "severity": "High",
  "comment": "Unused import `import org.eclipse.lsp4j.ClientInfo;`",
  "detailsInfo": "Reports redundant `import` statements.\n\nRegular `import` statements are unnecessary when not using imported classes and packages in the source file.\nThe same applies to imported `static` fields and methods that aren't used in the source file.\n\n**Example:**\n\n\n      import java.util.ArrayList;\n      public class Example {\n        public static void main(String[] args) {\n          System.out.println(\"Hello World!\");\n        }\n      }\n\nAfter the quick fix is applied:\n\n\n      public class Example {\n        public static void main(String[] args) {\n          System.out.println(\"Hello World!\");\n        }\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/codelenses/RunTestCodeLensSupplier.java",
      "language": "JAVA",
      "line": 36,
      "offset": 1,
      "length": 36,
      "code": {
        "startLine": 34,
        "length": 36,
        "offset": 55,
        "surroundingCode": "import lombok.Value;\nimport lombok.extern.slf4j.Slf4j;\nimport org.eclipse.lsp4j.ClientInfo;\nimport org.eclipse.lsp4j.CodeLens;\nimport org.eclipse.lsp4j.Command;"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "UNUSED_IMPORT"
  },
  "hash": "bff10a98b022a89be051d334f1c3e2cec9c3aa73710a4ae359c979eb4c7ad760"
},{
  "tool": "Code Inspection",
  "category": "Imports",
  "type": "Unused import",
  "severity": "High",
  "comment": "Unused import `import org.springframework.context.event.EventListener;`",
  "detailsInfo": "Reports redundant `import` statements.\n\nRegular `import` statements are unnecessary when not using imported classes and packages in the source file.\nThe same applies to imported `static` fields and methods that aren't used in the source file.\n\n**Example:**\n\n\n      import java.util.ArrayList;\n      public class Example {\n        public static void main(String[] args) {\n          System.out.println(\"Hello World!\");\n        }\n      }\n\nAfter the quick fix is applied:\n\n\n      public class Example {\n        public static void main(String[] args) {\n          System.out.println(\"Hello World!\");\n        }\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/codelenses/RunTestCodeLensSupplier.java",
      "language": "JAVA",
      "line": 40,
      "offset": 1,
      "length": 55,
      "code": {
        "startLine": 38,
        "length": 55,
        "offset": 77,
        "surroundingCode": "import org.eclipse.lsp4j.Command;\nimport org.eclipse.lsp4j.InitializeParams;\nimport org.springframework.context.event.EventListener;\nimport org.springframework.stereotype.Component;\n"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "UNUSED_IMPORT"
  },
  "hash": "e4dcd5985ca48bedffb99516ce3d1aef2a06ce457c0db764cef766fd6e6a89b1"
},{
  "tool": "Code Inspection",
  "category": "Imports",
  "type": "Unused import",
  "severity": "High",
  "comment": "Unused import `import com.github._1c_syntax.bsl.languageserver.events.LanguageServerInitializeRequestReceivedEvent;`",
  "detailsInfo": "Reports redundant `import` statements.\n\nRegular `import` statements are unnecessary when not using imported classes and packages in the source file.\nThe same applies to imported `static` fields and methods that aren't used in the source file.\n\n**Example:**\n\n\n      import java.util.ArrayList;\n      public class Example {\n        public static void main(String[] args) {\n          System.out.println(\"Hello World!\");\n        }\n      }\n\nAfter the quick fix is applied:\n\n\n      public class Example {\n        public static void main(String[] args) {\n          System.out.println(\"Hello World!\");\n        }\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/codelenses/RunTestCodeLensSupplier.java",
      "language": "JAVA",
      "line": 29,
      "offset": 1,
      "length": 100,
      "code": {
        "startLine": 27,
        "length": 100,
        "offset": 143,
        "surroundingCode": "import com.github._1c_syntax.bsl.languageserver.context.FileType;\nimport com.github._1c_syntax.bsl.languageserver.context.symbol.MethodSymbol;\nimport com.github._1c_syntax.bsl.languageserver.events.LanguageServerInitializeRequestReceivedEvent;\nimport com.github._1c_syntax.bsl.languageserver.utils.Resources;\nimport lombok.EqualsAndHashCode;"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "UNUSED_IMPORT"
  },
  "hash": "ea230cda8f931b9bc3e0d77e5432233bc482eb51a26d04fbe20b0c1b55c91c63"
}]}