{"version":"3","listProblem":[{
  "tool": "Code Inspection",
  "category": "Code maturity",
  "type": "Commented out code",
  "severity": "Moderate",
  "comment": "Commented out code (6 lines)",
  "detailsInfo": "Reports comments that contain Java code.\n\nUsually, code that is commented out gets outdated very quickly and becomes misleading.\nAs most projects use some kind of version control system,\nit is better to delete commented out code completely and use the VCS history instead.\n\nNew in 2020.3",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/inlayhints/SourceDefinedMethodCallInlayHintSupplier.java",
      "language": "JAVA",
      "line": 72,
      "offset": 1,
      "length": 2,
      "code": {
        "startLine": 70,
        "length": 2,
        "offset": 36,
        "surroundingCode": "    var range = params.getRange();\n\n//    var ast = documentContext.getAst();\n//    Trees.findAllRuleNodes(\n//      ast,"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "CommentedOutCode"
  },
  "hash": "5f0674d74495771954e4a3d3cbe6882a73d6c81eae51abc3ad43b4d2c3b0eb28"
},{
  "tool": "Code Inspection",
  "category": "Code style issues",
  "type": "Field may be 'final'",
  "severity": "High",
  "comment": "Field `newExpression` may be 'final'",
  "detailsInfo": "Reports fields that can be safely made `final`. All `final` fields have a value and this value does not change, which can make the code easier to reason about.\n\nTo avoid too expensive analysis, this inspection only reports if the field has a `private` modifier\nor it is defined in a local or anonymous class.\nA field can be `final` if:\n\n* It is `static` and initialized once in its declaration or in one `static` initializer.\n* It is non-`static` and initialized once in its declaration, in one instance initializer or in every constructor\n\nAnd it is not modified anywhere else.\n\n**Example:**\n\n\n      public class Person {\n        private String name; // can be final\n\n        Person(String name) {\n          this.name = name;\n        }\n\n        public String getName() {\n          return name;\n        }\n      }\n\nAfter the quick-fix is applied:\n\n\n      public class Person {\n        private final String name;\n\n        Person(String name) {\n          this.name = name;\n        }\n\n        public String getName() {\n          return name;\n        }\n      }\n\n\nUse the \"Annotations\" button to modify the list of annotations that assume implicit field write.",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/diagnostics/FileSystemAccessDiagnostic.java",
      "language": "JAVA",
      "line": 88,
      "offset": 18,
      "length": 13,
      "code": {
        "startLine": 86,
        "length": 13,
        "offset": 55,
        "surroundingCode": "    defaultValue = NEW_EXPRESSION\n  )\n  private String newExpression = NEW_EXPRESSION;\n  private Pattern newExpressionPattern = getPattern(newExpression);\n"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "FieldMayBeFinal"
  },
  "hash": "586a580b1bb96464e791cea05e4eece54e80d3cdfd87c93c982be82f9aa84bf5"
},{
  "tool": "Code Inspection",
  "category": "Code style issues",
  "type": "Field may be 'final'",
  "severity": "High",
  "comment": "Field `globalMethods` may be 'final'",
  "detailsInfo": "Reports fields that can be safely made `final`. All `final` fields have a value and this value does not change, which can make the code easier to reason about.\n\nTo avoid too expensive analysis, this inspection only reports if the field has a `private` modifier\nor it is defined in a local or anonymous class.\nA field can be `final` if:\n\n* It is `static` and initialized once in its declaration or in one `static` initializer.\n* It is non-`static` and initialized once in its declaration, in one instance initializer or in every constructor\n\nAnd it is not modified anywhere else.\n\n**Example:**\n\n\n      public class Person {\n        private String name; // can be final\n\n        Person(String name) {\n          this.name = name;\n        }\n\n        public String getName() {\n          return name;\n        }\n      }\n\nAfter the quick-fix is applied:\n\n\n      public class Person {\n        private final String name;\n\n        Person(String name) {\n          this.name = name;\n        }\n\n        public String getName() {\n          return name;\n        }\n      }\n\n\nUse the \"Annotations\" button to modify the list of annotations that assume implicit field write.",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/diagnostics/FileSystemAccessDiagnostic.java",
      "language": "JAVA",
      "line": 82,
      "offset": 18,
      "length": 13,
      "code": {
        "startLine": 80,
        "length": 13,
        "offset": 55,
        "surroundingCode": "    defaultValue = GLOBAL_METHODS\n  )\n  private String globalMethods = GLOBAL_METHODS;\n\n  @DiagnosticParameter("
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "FieldMayBeFinal"
  },
  "hash": "8db8387648e980deab9adfb4fc7c0715f0eec83b34126e32030a76651e400e9b"
},{
  "tool": "Code Inspection",
  "category": "Code style issues",
  "type": "Field may be 'final'",
  "severity": "High",
  "comment": "Field `checkAllRegion` may be 'final'",
  "detailsInfo": "Reports fields that can be safely made `final`. All `final` fields have a value and this value does not change, which can make the code easier to reason about.\n\nTo avoid too expensive analysis, this inspection only reports if the field has a `private` modifier\nor it is defined in a local or anonymous class.\nA field can be `final` if:\n\n* It is `static` and initialized once in its declaration or in one `static` initializer.\n* It is non-`static` and initialized once in its declaration, in one instance initializer or in every constructor\n\nAnd it is not modified anywhere else.\n\n**Example:**\n\n\n      public class Person {\n        private String name; // can be final\n\n        Person(String name) {\n          this.name = name;\n        }\n\n        public String getName() {\n          return name;\n        }\n      }\n\nAfter the quick-fix is applied:\n\n\n      public class Person {\n        private final String name;\n\n        Person(String name) {\n          this.name = name;\n        }\n\n        public String getName() {\n          return name;\n        }\n      }\n\n\nUse the \"Annotations\" button to modify the list of annotations that assume implicit field write.",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/diagnostics/PublicMethodsDescriptionDiagnostic.java",
      "language": "JAVA",
      "line": 60,
      "offset": 19,
      "length": 14,
      "code": {
        "startLine": 58,
        "length": 14,
        "offset": 71,
        "surroundingCode": "    defaultValue = \"\" + DEFAULT_CHECK_ALL_REGION\n  )\n  private boolean checkAllRegion = DEFAULT_CHECK_ALL_REGION;\n\n  @Override"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "FieldMayBeFinal"
  },
  "hash": "cda57a52bb546c25b7ad36a5e06ba15e4e1cfbd18d55b0c3e01f88deb76b3401"
},{
  "tool": "Code Inspection",
  "category": "Code style issues",
  "type": "Field may be 'final'",
  "severity": "High",
  "comment": "Field `validateNestedCalls` may be 'final'",
  "detailsInfo": "Reports fields that can be safely made `final`. All `final` fields have a value and this value does not change, which can make the code easier to reason about.\n\nTo avoid too expensive analysis, this inspection only reports if the field has a `private` modifier\nor it is defined in a local or anonymous class.\nA field can be `final` if:\n\n* It is `static` and initialized once in its declaration or in one `static` initializer.\n* It is non-`static` and initialized once in its declaration, in one instance initializer or in every constructor\n\nAnd it is not modified anywhere else.\n\n**Example:**\n\n\n      public class Person {\n        private String name; // can be final\n\n        Person(String name) {\n          this.name = name;\n        }\n\n        public String getName() {\n          return name;\n        }\n      }\n\nAfter the quick-fix is applied:\n\n\n      public class Person {\n        private final String name;\n\n        Person(String name) {\n          this.name = name;\n        }\n\n        public String getName() {\n          return name;\n        }\n      }\n\n\nUse the \"Annotations\" button to modify the list of annotations that assume implicit field write.",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/diagnostics/PrivilegedModuleMethodCallDiagnostic.java",
      "language": "JAVA",
      "line": 60,
      "offset": 19,
      "length": 19,
      "code": {
        "startLine": 58,
        "length": 19,
        "offset": 68,
        "surroundingCode": "    defaultValue = \"\" + VALIDATE_NESTED_CALLS\n  )\n  private boolean validateNestedCalls = VALIDATE_NESTED_CALLS;\n\n  private final ReferenceIndex referenceIndex;"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "FieldMayBeFinal"
  },
  "hash": "d1f280781daac21137305fea5680e8ca2a3cf5724eedd1806e37acf85093d3fa"
},{
  "tool": "Code Inspection",
  "category": "Verbose or redundant code constructs",
  "type": "Lombok @Getter may be used",
  "severity": "High",
  "comment": "Class 'CodeBlockVisitor' may use Lombok @Getter",
  "detailsInfo": "Reports standard getter method that can be replaced by the lombok `@Getter` annotation.\n\nExample:\n\n\n      import java.util.Date;\n\n      public class MyClass {\n        /**\n         * The process date.\n         */\n        private Date processDate;\n\n        /**\n         * Returns the date.\n         *\n         * @return The date\n         */\n        public Date getProcessDate() {\n          return processDate;\n        }\n      }\n\nAfter the quick-fix/cleanup is applied:\n\n\n      import lombok.Getter;\n      import java.util.Date;\n\n      @Getter\n      public class MyClass {\n        /**\n         * The process date.\n         * -- GETTER --\n         * Returns the date.\n         *\n         * @return The date\n         */\n        private Date processDate;\n      }\n\nIt only reports when the lombok library is configured. To unlombok, see the lombok site.\n\nNew in 2023.2",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/folding/CodeBlockFoldingRangeSupplier.java",
      "language": "JAVA",
      "line": 51,
      "offset": 24,
      "length": 16,
      "code": {
        "startLine": 49,
        "length": 16,
        "offset": 28,
        "surroundingCode": "  }\n\n  private static class CodeBlockVisitor extends BSLParserBaseVisitor<ParseTree> {\n\n    @Getter"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "LombokGetterMayBeUsed"
  },
  "hash": "7a81f66b127fdf10c2c864353ae1da075c18d9477d852294f3416ec5132cfc94"
},{
  "tool": "Code Inspection",
  "category": "Verbose or redundant code constructs",
  "type": "Lombok @Getter may be used",
  "severity": "High",
  "comment": "Class 'GenericIssueReport' may use Lombok @Getter",
  "detailsInfo": "Reports standard getter method that can be replaced by the lombok `@Getter` annotation.\n\nExample:\n\n\n      import java.util.Date;\n\n      public class MyClass {\n        /**\n         * The process date.\n         */\n        private Date processDate;\n\n        /**\n         * Returns the date.\n         *\n         * @return The date\n         */\n        public Date getProcessDate() {\n          return processDate;\n        }\n      }\n\nAfter the quick-fix/cleanup is applied:\n\n\n      import lombok.Getter;\n      import java.util.Date;\n\n      @Getter\n      public class MyClass {\n        /**\n         * The process date.\n         * -- GETTER --\n         * Returns the date.\n         *\n         * @return The date\n         */\n        private Date processDate;\n      }\n\nIt only reports when the lombok library is configured. To unlombok, see the lombok site.\n\nNew in 2023.2",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/reporters/GenericIssueReport.java",
      "language": "JAVA",
      "line": 42,
      "offset": 14,
      "length": 18,
      "code": {
        "startLine": 40,
        "length": 18,
        "offset": 50,
        "surroundingCode": "import java.util.stream.Collectors;\n\npublic class GenericIssueReport {\n\n  private static final Map<DiagnosticType, RuleType> diagnosticTypeRuleTypeMap = Map.of("
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "LombokGetterMayBeUsed"
  },
  "hash": "7c7556287ae694759028e902cad316197331fc354990d883813b4a03583e0f3f"
},{
  "tool": "Code Inspection",
  "category": "RegExp",
  "type": "Redundant character escape",
  "severity": "High",
  "comment": "Redundant character escape `\\\\*` in RegExp",
  "detailsInfo": "Reports redundant character escape sequences that can be replaced with unescaped characters preserving the meaning. Many escape sequences that are necessary outside of a character class are redundant inside square brackets `[]` of a character class.\n\n\nAlthough unescaped opening curly braces `{` outside of character classes are allowed in some dialects (JavaScript, Python, and so on),\nit can cause confusion and make the pattern less portable, because there are dialects that require escaping curly braces as characters.\nFor this reason the inspection does not report escaped opening curly braces.\n\n**Example:**\n\n\n      \\-\\;[\\.]\n\nAfter the quick-fix is applied:\n\n\n      -;[.]\n\n\nThe **Ignore escaped closing brackets '}' and '\\]'** option specifies whether to report `\\}` and `\\]` outside of a character class\nwhen they are allowed to be unescaped by the RegExp dialect.\n\nNew in 2017.3",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/diagnostics/UsingHardcodeSecretInformationDiagnostic.java",
      "language": "JAVA",
      "line": 67,
      "offset": 76,
      "length": 3,
      "code": {
        "startLine": 65,
        "length": 3,
        "offset": 81,
        "surroundingCode": "  );\n\n  private static final Pattern PATTERN_CHECK_PASSWORD = Pattern.compile(\"^[\\\\*]+$\", Pattern.UNICODE_CASE);\n\n  @DiagnosticParameter("
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "RegExpRedundantEscape"
  },
  "hash": "773d4bfe78dcae4ccaf24d64c6a67d700acfbba1c47d2e6a4bd3401a2492913c"
},{
  "tool": "Code Inspection",
  "category": "Verbose or redundant code constructs",
  "type": "Unnecessary 'continue' statement",
  "severity": "High",
  "comment": "`continue` is unnecessary as the last statement in a loop",
  "detailsInfo": "Reports `continue` statements if they are the last reachable statements in the loop. These `continue` statements are unnecessary and can be safely removed.\n\nExample:\n\n\n      for (String element: elements) {\n        System.out.println();\n        continue;\n      }\n\nAfter the quick-fix is applied:\n\n\n      for (String element: elements) {\n        System.out.println();\n      }\n\nThe inspection doesn't analyze JSP files.\n\n\nUse the **Ignore in then branch of 'if' statement with 'else' branch** option to ignore\n`continue` statements when they are placed in a `then` branch of a complete\n`if`-`else` statement.\n\nExample:\n\n\n      for (String element: elements) {\n        if(element.isEmpty()) {\n          continue;\n        } else {\n          //...\n        }\n      }\n",
  "sources": [
    {
      "type": "file",
      "path": "src/main/java/com/github/_1c_syntax/bsl/languageserver/utils/expressiontree/ExpressionTreeBuildingVisitor.java",
      "language": "JAVA",
      "line": 88,
      "offset": 11,
      "length": 8,
      "code": {
        "startLine": 86,
        "length": 8,
        "offset": 144,
        "surroundingCode": "          visitMember((BSLParser.MemberContext) child);\n        } else if (child.getClass() == BSLParser.PreprocessorContext.class) {\n          continue;\n        } else {\n          throw new IllegalStateException();"
      }
    }
  ],
  "attributes": {
    "module": "bsl-language-server.main",
    "inspectionName": "UnnecessaryContinue"
  },
  "hash": "1678974de8ae9e84bea2f4dfbbd77b13aff28fc3afdcfba5b091e63e3d8695ac"
}]}